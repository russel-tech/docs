{
  "openapi": "3.0.0",
  "info": {
    "description": "------  \nThis API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows:\n  - Checking name, address, date of birth against national databases\n  - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents\n  - Validating Australian electricity bills\n  - Validating NZ driver's licences\n  - Validating Chinese bank cards and national ID card\n  - Validating International passports and national ID documents\n  - PEP, Sanctions, Watchlist and adverse media checking\n  - Australian visa checks \n  - Fraud list and fraud background checks\n  - ID validation and selfie check comparisons.\n  \n------  \n \nKYB specific services\n\n  - Query organisation ownership\n  - Perform KYC & AML checks on shareholders, beneficial owners and office bearers.\n  - Query credit score and credit reports\n  - International company searches\n  - International company profiles\n  \n------  \nThe full version of this documentation along with supplemental articles can be found here:\n  - https://docs.frankieone.com/\n\n------\nSandbox base URL is:\n  - https://api.uat.frankie.one/compliance/v1.2\n  \n  - All calls are the same as production, only with test data. You can download the latest test data here: https://docs.frankieone.com/docs/test-data\n\n  - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced.\n\n  - Production and optional UAT access will be opened up only to those with a signed commercial contract.\n  \n------  \nContact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key.\n",
    "title": "Frankie Financial API",
    "contact": {
      "email": "help@frankieone.com"
    },
    "version": "1.15.3"
  },
  "paths": {
    "/business/international/profile": {
      "post": {
        "description": "Using the Company Code retrieved from the search response (see above: https://docs.frankieone.com/reference/internationalbusinesssearch) you can pull back the details of the company.\n\nThe FrankieOne platform will save the details of the response as an ORGANISATION type entity with the retrieved profile attached as a report which you can potentially re-retrieve later if you wish.\n",
        "tags": ["Business"],
        "summary": "(International) Retrieve a business profile from any country.",
        "operationId": "InternationalBusinessProfile",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InternationalBusinessProfileCriteria"
              }
            }
          },
          "description": "The country, company code and optional registry of the organisation to be queried.\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and was successfully processed. The search has been carried out and the results are attached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternationalBusinessProfileResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/international/search": {
      "post": {
        "description": "Search for a given business name or business number across international business registers.\n\nThe search will return a list of matching companies that you can then potentially query using the international profile query (see below).\nEach search result will have a CompanyCode that you use to retrieve the specific company details using the profile function.\n\n* Note:* This process will *not* save any details from the search results.\n",
        "tags": ["Business"],
        "summary": "(International) Search for a business from any country.",
        "operationId": "InternationalBusinessSearch",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a FrankieOne Customer, you are acting on behalf of your own customers, then you can populate this field with a FrankieOne-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InternationalBusinessSearchCriteria"
              }
            }
          },
          "description": "The country, name or business number of the organisation to be queried.\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and was successfully processed. The search has been carried out and the results are attached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternationalBusinessSearchResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/ownership/query": {
      "post": {
        "description": "Process a request for ownership details for an Australian organisation ONLY.\n\nSee below for more general international queries.\n\nAt a minimum, you just need to supply an ACN or ABN and we can retrieve the rest.\nYou also have the option of supplying company name, type (as per ABR types) and both ABN/ACN and we'll attempt to verify that that data matches what is on record before attempting any further verification and validation.\n\nKYC/AML for a selection of entities associated with an organisation and/or the organisation itself can optionally be run, but not by default. To enable KYC/AML checks one or more entity categories must be provided. If such a list of entity categories is given then default checks based on configuration will be run for those categories. If a check type is also provided in the request then that type will be used for entities representing individual entities, and the AML subset of that check will be used for organisations if any. Specifying a check type without an entity category will result in an error.\n\n*NOTE:* A 202 ACCEPT response will be returned if there are full ownership details to be retrieved or there is entity verification requested.\nIn this case results will be pushed using the Push Notification API below and you will be able to retrieve the results using the Retrieve API.\n\nIf only basic ownership (profile only) is requested with no entity verification, then the result will be a 200 OK.\n\nMore details on how to use this API and interpret the results can be found here:\n  \n  https://docs.frankieone.com/docs/australian-business-function-overview\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Create Business Entity and Query UBO",
        "operationId": "BusinessOwnershipQuery",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When creating a new check, we need to define the checks we wish to run. If this parameter is not supplied then the check will be based on a configured check type for each entity category.\n  \nThe checkType is make up of a comma separated list of the types of check we wish to run.\n\nThe order is important, and must be of the form:\n  - Entity Check (if you're running this). Choose one from the available options\n  - ID Check (If you want this)\n  - PEP Checks (again if you want this, choose one of the options)\n\nEntity Checks - One of:\n  - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)\n  - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)\n\nID Checks - One of:\n  - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.\n  \nFraud Checks - One or more  of:\n  - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.\n  - \"fraudid\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)\n  \nPEP Checks - One of:\n  - \"pep\": Will only run PEP/Sanctions checks (no identity verification)\n  - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)\n  \n  * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.\n\nPre-defined combinations (deprecated):\n  - \"full\": equivalent to \"two_plus,id,pep_media\" or \"pep_media\" if the target is an organisation.\n  - \"default\": Currently defined as \"two_plus,id\" or \"pep\" if the target is an organisation.\n\n  * NOTE: These options are now deprecated and support for these options will be eventually halted. Please specify check_types explicitly.\n  \nCustom:\n  - By arrangement with Frankie you can define your own KYC check type.\n  \n  This will allow you to set the minimum number of matches for:\n    - name \n    - date of birth\n    - address\n    - government id\n  \n  This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).\n  \nProfile:\n  - \"profile\": By arrangement with Frankie you can have a \"profile\" check type that applies checks according to a profile that you assign to the entity from a predefined set of profiles.\n  \n  The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.\n  \n  Profiles act a little like the Pre-defined combinations above in that they can map to a defined list. But they offer a lot more besides, including rules for determining default settings, inbuild data aging and other configurable features.\n  They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.\n  \n  Entity Profiles are the future of checks with Frankie Financial.\n",
            "name": "checkType",
            "in": "query",
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "enum": [
                  "one_plus",
                  "two_plus",
                  "id",
                  "fraudlist",
                  "fraudcheck",
                  "pep",
                  "pep_media",
                  "profile",
                  "full",
                  "default"
                ],
                "type": "string"
              },
              "uniqueItems": true
            }
          },
          {
            "description": "A comma separated list that specifies the categories of entities associated with the target organisation that will be checked.\n\n  - organisation - Just the organisation itself.\n  - ubos - All ultimate beneficial owners.\n  - pseudo_ubos - Use an alternative category when an organisation has no actual UBOs. The actual category to use is defined via configuration, default is no alternative category.\n  - nibos - Non-Individual Beneficial Owners\n  - bos_associated - Beneficial owners that have been manually associated, rather than retrieved from registry sources\n  - direct_owners - All direct owners of the company, both organisations and individuals, may include UBOs for for simple ownership.\n  - officers - All officers of the company\n  - officers_directors - All directors of the company\n  - officers_secretaries - All secretaries of the company\n  - officers_other - All non-director officers of the company\n  - officers_associated - All officers of the company that were associated manually, rather than retrieved from registry sources\n  - all - All direct and indirect owners, both organisations and individuals (including UBOs), and officers of all organisations.\n",
            "name": "entityCategories",
            "in": "query",
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "enum": [
                  "organisation",
                  "ubos",
                  "pseudo_ubos",
                  "nibos",
                  "bos_associated",
                  "direct_owners",
                  "officers",
                  "officers_directors",
                  "officers_secretaries",
                  "officers_other",
                  "officers_associated",
                  "all"
                ],
                "type": "string"
              },
              "uniqueItems": true
            }
          },
          {
            "description": "The result level allows you to specify the level of detail returned for the entity check. You can choose summary or full.\n",
            "name": "resultLevel",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": ["summary", "full"],
              "default": "summary"
            }
          },
          {
            "description": "Should a validation check be run before the ownership query. The default is specified via configuration. The validation checks to see if the provided organisation is suitable for an ownership query by looking for the ACN in public data sources. \nOptions are:\n- \"on\": Validate only when ACN is not provided. This is the typical default.\n- \"acn\": Validate even if ACN is provided.\n- \"only\": Like \"acn\" but only do validation query, don't proceed with ownership query. This option cannot be set as the default via configuration.\n- \"off\": Never validate. The Ownership query will then fail if an ACN is not provided.\n",
            "name": "validation",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": ["on", "off", "only", "acn"]
            }
          },
          {
            "description": "The type of human readable report, if any, to generate based on the ownership query results.\nOptions are:\n  - SINGLE-LEVEL-AML: ASIC report\n  - UBO: UBO report\n",
            "name": "generateReport",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": ["SINGLE-LEVEL-AML", "UBO"]
            }
          },
          {
            "description": "Name of configured preset query parameters to use. Any individual parameters provided in the\nrequest will override the same parameter in the configured preset.\n",
            "name": "preset",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If set to true, historical ownership data will be requested.\n",
            "name": "includeHistorical",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "If set to true, a full UBO report will not be requested.\nNote: This param is deprecated, use ownershipMode instead.\n",
            "name": "onlyProfile",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Do not load the named result objects from cache, but force them to be retrieved from an approproate service, if and when they are required.\nOptions are:\n- abr\n- ownership\n",
            "name": "noLoad",
            "in": "query",
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "uniqueItems": true
            }
          },
          {
            "description": "Define the ownership mode you wish to run.\n\nValid ownership modes are:\n  - full\n  - onlyProfile\n  - onlyUBO\n",
            "name": "ownershipMode",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": ["full", "onlyProfile", "onlyUBO"]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OwnershipQuery"
              }
            }
          },
          "description": "The organisation to be queried. An entity object that must have an organisation object with at least one organisation number.\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "This is what you will find in the payload of a retrieved response should the ownership query succeed, or you're querying the past checks for a given business.\n\nNOTE:\n  When requesting the initial report, you will only ever receive a 202 response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganisationCheckResponseObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/reports": {
      "post": {
        "description": "NOTE: Australian companies ONLY.\nCreate or find and update an ORGANISATION type entity, then run the requested reports.\nReports include:\n - Credit Report\n - Credit Score\n - Payment Predictor\n\nAt a minimum, you just need to supply an ACN and/or ABN and an entity type set to ORGANISATION. Alternatively the entity ID of an existing ORGANISATION entity gan be given in the request body\n\nNote: these reports are different to the Ultimate Beneficial Owner and Business Detail requests - these reports are independent data and analysis over and above company information and verification details.\n\nYou can request multiple reports to be run at once and they will be returned as a group.\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Run Report(s) against a new or existing organisation entity.",
        "operationId": "RunBusinessReports",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Define the report(s) you wish to run.\n\nYou can request more than one as a comma separated list. \nDuplicates will be ignored.\n\nNote: These reports are different to the business details and UBO queries and are meant to provide deeper detail and background on a business or organisation.\n  \nCurrent valid report types are:\n  - creditScore\n  - creditReport\n  - paymentPredictor\n",
            "name": "reportTypes",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/EntityObject"
        },
        "responses": {
          "200": {
            "description": "The request was valid and was successfully processed. The report was run and the results have been attached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BusinessReportResponseDetails"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/reports/multi": {
      "post": {
        "description": "NOTE: Australian companies ONLY.\n\nCreate or find and update an ORGANISATION type entity, then run the requested reports.\nReports include:\n - Credit Report\n - Credit Score\n - Payment Predictor\n\nAt a minimum, you just need to supply an ACN and/or ABN and an entity type set to ORGANISATION. Alternatively the entity ID of an existing ORGANISATION entity gan be given in the request body\n\nNote: these reports are different to the Ultimate Beneficial Owner and Business Detail requests - these reports are independent data and analysis over and above company information and verification details.\n\nYou can request multiple reports to be run at once and they will be returned as a group.\n\nIf a PDF report is requested then that report will be generated over time, so a temporary response with only the JSON reports will be returned and a webhook notification will be pushed later once the PDF report has been completed.\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Run Report(s) against a new or existing organisation entity and produce a PDF formatted document.",
        "operationId": "RunBusinessReportsMulti",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Define the report(s) you wish to run.\n\nYou can request more than one as a comma separated list. \nDuplicates will be ignored.\n\nNote: These reports are different to the business details and UBO queries and are meant to provide deeper detail and background on a business or organisation.\n  \nCurrent valid report types are:\n  - creditScore\n  - creditReport\n  - paymentPredictor\n",
            "name": "reportTypes",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Should the report(s) also be generated as a PDF document.\n",
            "name": "pdf",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/EntityObject"
        },
        "responses": {
          "200": {
            "description": "The request was valid and was successfully processed. The report was run and the results have been attached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BusinessReportResponseDetails"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fullfilled. The Frankie service has now accepted responsibility for processing and will send you a notification when the reports are ready.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BusinessReportResponseDetails"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/{entityId}/associateEntity/new": {
      "post": {
        "description": "Create an entity with the provided details, then associated it with a parent organisation.\n\nThe referenced parent entity must be of type ORGANISATION and an ownership query must have been previously completed.\n\nAt least the entity name (family name for individuals, registered name for organisations) must be provided in entity.\n\nAt least one of role or percentage held must be in the request. If either is null or omitted, then any existing details will\nbe retained. If either detail is given, the it will be replaced, not merged.\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Make a new entity a direct associated entity of a parent organisation.",
        "operationId": "CreateAssociateEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StaticEntityAssociationRequest"
              }
            }
          },
          "description": "The entity and role for the association to be created.\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and was successfully processed. The entity association has been updated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StaticEntityAssociationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/{entityId}/associateEntity/{otherId}": {
      "post": {
        "description": "Update an entity with the provided details, then associated it with a parent organisation, or update any existing association.\n\nTo use an existing entity, and not update it, either omit the entity field, use null, or just provide an entity object that\ncontains only the entity ID, which must match the one given in the request URL.\n\nAt least the entity name (family name for individuals, registered name for organisations) must be present in the entity after\nany update.\n\nThe referenced parent entity must be of type ORGANISATION and an ownership query must have been previously completed.\n\nAt least one of role or percentage held must be in the request. If either is null or omitted, then any existing details will\nbe retained. If either detail is given, the it will be replaced, not merged.\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Make an existing entity (otherId) a direct associated entity of a parent organisation (entityId), or update an existing association.",
        "operationId": "UpdateAssociateEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds",
            "name": "otherId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StaticEntityAssociationRequest"
              }
            }
          },
          "description": "The role and optional updated entity details for the association to be created.\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and was successfully processed. The entity association has been updated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StaticEntityAssociationResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Remove the association between the two given entities.\n\nIf the association doesn't exist an error will be returned.\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Remove a previously created association between an entity (otherId) and a parent organisation (entityId).",
        "operationId": "DeleteEntityAssociation",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds",
            "name": "otherId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and was successfully processed. The entity association has been deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BasicStatusResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/{entityId}/checks": {
      "get": {
        "description": "Retrieve results from a previous UBO query along with the current KYC/AML results (if any) for associated entities.\n\n*NOTE:* This will only return check details for an Australian Organisation that has previously \ncalled one of the following calls:\n\n  * Create Business and Query UBO call (/reference/businessownershipquery) or\n  * Run KYC/AML Checks on Organisation (/reference/checkorganisation)\n\nMore details on how to use this API and interpret the results can be found here:\n\n  https://docs.frankieone.com/docs/australian-business-function-overview\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Retrieve previous UBO query results",
        "operationId": "QueryOwnershipChecks",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "in": "query",
            "name": "documentData",
            "required": false,
            "description": "The type of document data to return - with document scans or not. Default is 'full'.\n",
            "schema": {
              "type": "string",
              "enum": [
                "meta",
                "full"
              ],
              "default": "full"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "This is what you will find in the payload of a retrieved response should the ownership query succeed, or you're querying the past checks for a given business.\n\nNOTE:\n  When requesting the initial report, you will only ever receive a 202 response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganisationCheckResponseObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/{entityId}/list": {
      "get": {
        "description": "Lists documents available for order on the entity. This currently only supports entities created through /business/international/profile. (/reference/internationalbusinessprofile)\n\nFor further details, see https://docs.frankieone.com/docs/getting-a-list-of-documents\n",
        "tags": ["Business"],
        "summary": "(International) List available documents in catalogue",
        "operationId": "BusinessDocumentCatalogue",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "The entityId of a business entity returned by a successful call to /business/international/profile",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of documents available for order for this entity.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BusinessReportOrderListResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/{entityId}/parentAssociations": {
      "get": {
        "description": "Retrieve all the parent associations for an Individual or a Business\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Retrieve all the parent associations for an Individual or a Business",
        "operationId": "QueryParentAssociations",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Depth to which we need to retrieve parent entities. Values could be \"FULL\" or an integer. This param is optional. Default depth is FULL.\n",
            "name": "resultLevel",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "This is the payload for parent associations request. It contains all the parent associations for a given entity.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParentAssociationsQueryResult"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/{entityId}/report": {
      "get": {
        "description": "Get the status of a previously ordered business report for an entity. To fetch the status and details you just provide the requestID and the entityID.\nTo retrieve all previous orders for an entity, just provide the entityID.\n",
        "tags": ["Business"],
        "summary": "(International) Get status of document order",
        "operationId": "OrderBusinessDocumentStatus",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "The entityId of a business entity returned by a successful call to /business/international/profile",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "The requestId that was received when ordering a report. Do not pass this to retrieve all document order statuses for the entity",
            "name": "requestId",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "ulid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Status for this business report order is available.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BusinessReportOrderStatusResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Orders a document relevant to the entity. To discover what documents are available, you should list document catalogue first. On success, will return a 202 response. Frankie systems will poll the provider in the background for the document and attach it to the entity once it is ready, sending you a push notification on completion (if configured).\n\nFor further details of this process and document retrieval, see https://docs.frankieone.com/docs/order-a-document\n",
        "tags": ["Business"],
        "summary": "(International) Order document from catalogue",
        "operationId": "OrderBusinessDocument",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "The entityId of a business entity returned by a successful call to /business/international/profile",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/dummyA0111"
              }
            }
          },
          "description": "Details required to order the document. The reportCode should come\nfrom the catalogue request.\n",
          "required": true
        },
        "responses": {
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/{entityId}/subscription": {
      "post": {
        "description": "Manage subscription to continuous monitoring of business details and ownership (AUS Only). To subscribe or add an entity to the watch list set the entity flag to true. To unsubscribe or remove an entity from the watch list the entity flag needs to be set to false. All new entities created are by default added to the watch list with the flag set as true.\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Subscribe or unsubscribe to continuous monitoring of business details and ownership.",
        "operationId": "BusinessOwnershipSubscription",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Set the value of an entity flag.\n",
            "name": "set",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and was successfully processed. The subscription status has been updated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BusinessSubscriptionResponseObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/business/{entityId}/verify": {
      "post": {
        "description": "Run KYC/AML for a selection of entities associated with an organisation and/or the organisation itself based on a previous ownership query.\nBy default AML will be checked for just the organisation itself. If a list of entity categories is given then default checks based on configuration will be run for those categories. If a check type is also provided in the request then that type will be used for entities representing individual entities, and the AML subset of that check will be used for organisations if any.\nIf no ownership query has been run, then this operation will return an error.\n\n*NOTE:* This will only return check details for an Australian Organisation that has previously called:\n\n  * Create Business and Query UBO call (/reference/businessownershipquery)\n",
        "tags": ["Business"],
        "summary": "(AUS Only) Run KYC/AML Checks on Organisation and/or Associated Individuals.",
        "operationId": "CheckOrganisation",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "When creating a new check, we need to define the checks we wish to run. If this parameter is not supplied then the check will be based on a configured check type for each entity category.\n  \nThe checkType is make up of a comma separated list of the types of check we wish to run.\n\nThe order is important, and must be of the form:\n  - Entity Check (if you're running this). Choose one from the available options\n  - ID Check (If you want this)\n  - PEP Checks (again if you want this, choose one of the options)\n\nEntity Checks - One of:\n  - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)\n  - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)\n\nID Checks - One of:\n  - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.\n  \nFraud Checks - One or more  of:\n  - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.\n  - \"fraudid\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)\n  \nPEP Checks - One of:\n  - \"pep\": Will only run PEP/Sanctions checks (no identity verification)\n  - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)\n  \n  * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.\n\nPre-defined combinations (deprecated):\n  - \"full\": equivalent to \"two_plus,id,pep_media\" or \"pep_media\" if the target is an organisation.\n  - \"default\": Currently defined as \"two_plus,id\" or \"pep\" if the target is an organisation.\n\n  * NOTE: These options are now deprecated and support for these options will be eventually halted. Please specify check_types explicitly.\n  \nCustom:\n  - By arrangement with Frankie you can define your own KYC check type.\n  \n  This will allow you to set the minimum number of matches for:\n    - name \n    - date of birth\n    - address\n    - government id\n  \n  This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).\n  \nProfile:\n  - \"profile\": By arrangement with Frankie you can have a \"profile\" check type that applies checks according to a profile that you assign to the entity from a predefined set of profiles.\n  \n  The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.\n  \n  Profiles act a little like the Pre-defined combinations above in that they can map to a defined list. But they offer a lot more besides, including rules for determining default settings, inbuild data aging and other configurable features.\n  They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.\n  \n  Entity Profiles are the future of checks with Frankie Financial.\n",
            "name": "checkType",
            "in": "query",
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "enum": [
                  "one_plus",
                  "two_plus",
                  "id",
                  "fraudlist",
                  "fraudcheck",
                  "pep",
                  "pep_media",
                  "profile",
                  "full",
                  "default"
                ],
                "type": "string"
              },
              "uniqueItems": true
            }
          },
          {
            "description": "A comma separated list that specifies the categories of entities associated with the target organisation that will be checked.\n\n  - organisation - Just the organisation itself.\n  - ubos - All ultimate beneficial owners.\n  - pseudo_ubos - Use an alternative category when an organisation has no actual UBOs. The actual category to use is defined via configuration, default is no alternative category.\n  - nibos - Non-Individual Beneficial Owners\n  - bos_associated - Beneficial owners that have been manually associated, rather than retrieved from registry sources\n  - direct_owners - All direct owners of the company, both organisations and individuals, may include UBOs for for simple ownership.\n  - officers - All officers of the company\n  - officers_directors - All directors of the company\n  - officers_secretaries - All secretaries of the company\n  - officers_other - All non-director officers of the company\n  - officers_associated - All officers of the company that were associated manually, rather than retrieved from registry sources\n  - all - All direct and indirect owners, both organisations and individuals (including UBOs), and officers of all organisations.\n",
            "name": "entityCategories",
            "in": "query",
            "style": "form",
            "explode": false,
            "schema": {
              "type": "array",
              "items": {
                "enum": [
                  "organisation",
                  "ubos",
                  "pseudo_ubos",
                  "nibos",
                  "bos_associated",
                  "direct_owners",
                  "officers",
                  "officers_directors",
                  "officers_secretaries",
                  "officers_other",
                  "officers_associated",
                  "all"
                ],
                "type": "string"
              },
              "uniqueItems": true
            }
          },
          {
            "description": "The result level allows you to specify the level of detail returned for the entity check. You can choose summary or full.\n",
            "name": "resultLevel",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": ["summary", "full"],
              "default": "summary"
            }
          },
          {
            "description": "The type of human readable report, if any, to generate based on the ownership query results.\nOptions are:\n  - SINGLE-LEVEL-AML: ASIC report\n  - UBO: UBO report\n",
            "name": "generateReport",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": ["SINGLE-LEVEL-AML", "UBO"]
            }
          },
          {
            "description": "Name of configured preset query parameters to use. Any individual parameters provided in the\nrequest will override the same parameter in the configured preset.\n",
            "name": "preset",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/document": {
      "post": {
        "description": "Create a document object. A document object can be used to simply store data around a given identity or similar document. You can attach scans, PDFs, photos, videos, etc to the object if you wish.\n",
        "tags": ["Document"],
        "summary": "Create New Document.",
        "operationId": "CreateDocument",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IdentityDocumentObject"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the document object as it stands now. No docScan file data will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/document/new/verify": {
      "post": {
        "description": "Send the document to an external service to have the detailed verified.\n\nFor example, we could send through the details of a drivers licence to be checked against a national database.\n",
        "tags": ["Document"],
        "summary": "Create and Verify Document.",
        "operationId": "VerifyDocument",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentVerify"
              }
            }
          },
          "description": "The document and (possibly) its associated scans to be verified.\n\nThere is also an entity object (normally stripped back to it's bare minimum) that can be used to provide supporting data, such as name, address, etc. The entity object may be empty/\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the results of the document verification process.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentVerifyResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedDocumentResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/document/search": {
      "post": {
        "description": "\nSearch for an existing document that matches the criteria supplied\n\nThere are of course limits to what can be searched upon. For a document search to work, you must supply at a minimum:\n\n  * idType\n  * country\n  * idNumber\n\nThe service will return a list of matching documents with confidence levels.\n\nIf you are the \"owner\" of the document - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the document will be returned, except for the contents of any attached scans.\nIf you are not the owner of the document, then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET /document/{documentId}/checks)\n\nNote: At this time, we cannot perform searches on document scans. But, you can supply extraData KVPs if they're known. These will help double check search results with ambiguous results.\n",
        "tags": ["Document"],
        "summary": "Search For a Document",
        "operationId": "SearchDocument",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IdentityDocumentObject"
              }
            }
          },
          "description": "A document object with the parameters you wish to search on.\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Returns a list of potentially matching documents or document references, along with a confidence level in the match.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentSearchResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/document/{documentId}": {
      "get": {
        "description": "Query the current status and details of a given documentId.\n",
        "tags": ["Document"],
        "summary": "Retrieve Document Details",
        "operationId": "QueryDocument",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The documentId returned previously from an earlier call to /check or /entity or /document",
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the document object as it stands now. No docScan file data will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Using a previously uploaded but incomplete document, you can optionally supply updated details (such as corrections on a previous scan), along with one or more additional ID scans (e.g. additional pages).\n",
        "tags": ["Document"],
        "summary": "Update Existing Document.",
        "operationId": "UpdateDocument",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The documentId returned previously from an earlier call to /check or /entity or /document",
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Disable check result invalidation for this update request.\n",
            "name": "noInvalidate",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IdentityDocumentObject"
              }
            }
          },
          "description": "The document to be updated",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the document object as it stands now. No docScan file data will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedDocumentResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Mark this document as deleted. It will then become effectively invisible to all queries, but will be available in anonymised form for a past check.\n",
        "tags": ["Document"],
        "summary": "Delete Document.",
        "operationId": "DeleteDocument",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The documentId returned previously from an earlier call to /check or /entity or /document",
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Returns a simple status to indicate that the deletion has taken place.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BasicStatusResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedDocumentResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/document/{documentId}/checks": {
      "get": {
        "description": "Get the complete list of all checks that have been performed upon a given document, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details).\n",
        "tags": ["Document"],
        "summary": "Retrieve Document Verification Check Details.\n",
        "operationId": "QueryDocumentChecks",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The documentId returned previously from an earlier call to /check or /entity or /document",
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the results of all checks carried out upon this document.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentChecksResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedDocumentResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/document/{documentId}/full": {
      "get": {
        "description": "Query the current status and details of a given documentId. Also returns all document file data, not just the metadata.\n",
        "tags": ["Document"],
        "summary": "Retrieve Document and Scan Data",
        "operationId": "QueryDocumentFull",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The documentId returned previously from an earlier call to /check or /entity or /document",
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the document object as it stands now. No docScan file data will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/document/{documentId}/verify": {
      "post": {
        "description": "Using a previously uploaded but potentially incomplete document, you can optionally supply updated details (such as corrections on a previous scan), along with one or more additional ID scans (e.g. additional pages). Includes a follow-on action as well initiating verification procedures immediately.\n\nSends the updated document to an external service to have the detailed verified.\n\nFor example, we could send through the details of a drivers licence to be checked against a national database.\n",
        "tags": ["Document"],
        "summary": "Update and Verify Document.",
        "operationId": "UpdateVerifyDocument",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The documentId returned previously from an earlier call to /check or /entity or /document",
            "name": "documentId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentVerify"
              }
            }
          },
          "description": "The document and (possibly) its associated scans to be verified.\n\nThere is also an optional entity object (normally stripped back to it's bare minimum) that can be used to provide supporting data, such as name, address, etc. The entity object may be empty, and is not processed or stored in any way.\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the results of the document verification process.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentVerifyResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedDocumentResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity": {
      "post": {
        "description": "Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity.\n\nEntity objects can be used to run a check, using the data held in the records.\n",
        "tags": ["Entity"],
        "summary": "Create New Entity.",
        "operationId": "CreateEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityObject"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/new/idvalidate/getToken": {
      "post": {
        "description": "Create an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app) \n\nAt a minimum, you will need to supply:\n - the entity familyName. \n - the entity givenName\n \n For best results, you should gather the DoB, address, ID document details as well before  calling the initProcess function.\n\nSPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function. \n\nSPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process.\n",
        "tags": ["Entity"],
        "summary": "Create Entity and Get IDV Token",
        "operationId": "CreateEntityGetIDVToken",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityIDVDetailsObject"
              }
            }
          },
          "description": "The entity and required data to generate an IDV token",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.\n\nAlso returned is the applicantId and token to be in the IDV process.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityIDVResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/new/verify/pushToMobile": {
      "post": {
        "description": "Create an entity object and begin the process of verification after pushing a message to a mobile number. \nThe entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.\n\nAt a minimum, you will need to supply the name and a MOBILE_PHONE document type. \n\nSPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer support to arrange this.\n",
        "tags": ["Entity"],
        "summary": "Create Entity and Push Self-Verification Link",
        "operationId": "CreateCheckEntityPushToMobile",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/EntityCheckDetailsObject"
        },
        "responses": {
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/new/verify/{checkType}/{resultLevel}": {
      "post": {
        "description": "Create an entity object. An entity object can be used to simply store data around a given identity. You can attach ID documents, scans, PDFs, photos, videos, etc to the entity if you wish.\n\nIf the entity is successfully created, take the details and documents provided, and set about verifying them all.\nSo for example, you might extract:\n\n* The name from the entity.name object\n* The address from the entity.address object\n* The DoB..\n\nAll documents that are attached to the entity will also be verified (if possible).\n\nYou can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.\n\nSPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.\n\nYour account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless.\n",
        "tags": ["Entity"],
        "summary": "Create and Verify Entity",
        "operationId": "CreateCheckEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When creating a new check, you need to define the checks you wish to run.\n  \nThe checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.\n\n  The validation that is performed on the requested checks is to:\n  - ensure the check type is known\n  - is suitable for the type of entity (no KYC for organisations)\n  - disallow manual (mKYC) check with any other kind of KYC\n  - disallow mixing the \"profile\" check with any other kind of check.\n\nThe supported check types are:\n\nProfile:\n  - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.\n  \n  The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.\n  \n  Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.\n  They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.\n  \n  Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.\n\n**Individual Check Types**\n\nWhilst we strongly recommend the use of the \"profile\" checktype, it does map to any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.\n\nEntity Checks - One of:\n  - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)\n  - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)\n\nID Checks - One of:\n  - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.\n  - \"visa\":\n  \nID Validate - One of:\n  - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.\n  \nManual Check:\n  - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.\n  \nFraud Checks - One or more of:\n  - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.\n  - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)\n  \nPEP Checks - One of:\n  - \"pep\": Will only run PEP/Sanctions checks (no identity verification)\n  - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)\n  \n  * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.\n\nDevice checks:\n  - \"device\": This will allow you to pass in device details captured through services like ThreatMetrix or Sardine.ai\n\nCustom:\n  - By arrangement with Frankie you can define your own KYC check type.\n  \n  This will allow you to set the minimum number of matches for:\n    - name \n    - date of birth\n    - address\n    - government id\n  \n  This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). \n  Speak with the Customer Success team when you're onboarding.\n",
            "name": "checkType",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "profile"
            }
          },
          {
            "description": "How much detail we return. \n\nAcceptable values are:\n  * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.\n  * summary\n  * full - You need to have your account configured for this.\n",
            "name": "resultLevel",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["simple", "summary", "full"]
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/EntityCheckDetailsObject"
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckEntityCheckResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/search": {
      "post": {
        "description": "\nSearch for an existing entity that matches the criteria supplied\n\nCriteria are supplied in the form of a populated entity object, with the name/address/DoB details supplied.\nYou can also include documents that can be used to further refine your search (see the /document/search function for minimum requirements for a document search)\n\nAt an absolute minimum, you must supply one of the following combinations:\n\n  * name.familyName +\n  * name.givenNames\n  \n  or\n  \n  * name.familyName +\n  * one identityDocument object (that meets minimum criteria)\n  \nObviously, the more data you provide, the better search results we can provide.\n\nThe service will return a list of matching entities with confidence levels.\n\nIf you are the \"owner\" of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.\n\nIf you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)\n\nIf you're operating a parent account, you can also optionally include your child accounts in the search by specifying child=true in the query parameters.\n\nNote: This functionality must be enabled by Frankie administrators. Please contact your sales representative if you wish to discuss this.\n",
        "tags": ["Entity"],
        "summary": "Search for Entity",
        "operationId": "SearchEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Optionally include child accounts in your search\n",
            "name": "child",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "The type of search to score matches for.\n\nThis parameter should not be specified unless by specific arrangement with Frankie.\n\nIf the search type \"none\" is used, then no scoring will be applied and there will be no confidence level for the results.\n",
            "name": "searchType",
            "in": "query",
            "schema": {
              "type": "string",
              "default": "entity_search"
            }
          },
          {
            "description": "Only include entity IDs in the search results, not whole entities\n",
            "name": "onlyEntityIds",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Limit the number of search results returned. Results may also be capped by a hard limit applied by the search service.\n",
            "name": "resultLimit",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityObject"
              }
            }
          },
          "description": "An entity object with the parameters you wish to search on.\n",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Returns a list of potentially matching entity or entity references, along with a confidence level in the match.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntitySearchResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}": {
      "get": {
        "description": "Query the current status and details of a given entityId.\n",
        "tags": ["Entity"],
        "summary": "Retrieve Entity Details",
        "operationId": "QueryEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Optionally include child accounts in your search\n",
            "name": "child",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Using a previously uploaded but incomplete Entity, you can optionally supply updated details (such as corrections on a previous address), along with one or more additional ID docs/scans (e.g. new documents to parse, etc).\n",
        "tags": ["Entity"],
        "summary": "Update Existing Entity",
        "operationId": "UpdateEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Disable check result invalidation for this update request.\n",
            "name": "noInvalidate",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityObject"
              }
            }
          },
          "description": "The entity to be updated",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Marks the entity as deleted in the system, and no further operations or general queries may be executed against it by the Customer. If another customer is presently relying on this data, it will still be available to them (but only in the partially anonymised form they originally had.\n\nAn entity and its related data is only completely deleted from the database when either:\n\n  - a) There are no more references to it (i.e. it has been DELETEd by all Customers relying on the data), and 12 months have passed.\n  \n  - b) The actual consumer who owns the data makes a direct request. If this occurs, then all subscribing Customers will be notified that this entity has been removed and they will need to contact them if needed in order to update their own records again.\n",
        "tags": ["Entity"],
        "summary": "Delete Entity",
        "operationId": "DeleteEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Returns a simple status to indicate that the deletion has taken place.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BasicStatusResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/check/{checkId}/{checkClass}": {
      "post": {
        "description": "Internal only\n\nUpdate a given set of KYC and/or AML check result statuses in order to force a re-evaluation of the overall check result.\n",
        "tags": ["Entity"],
        "summary": "Update Check Result States (Batch)",
        "operationId": "UpdateCheckClassResults",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "The checkId returned previously from an earlier call to */verify",
            "name": "checkId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Specify which check Class this action will apply to (PRO, BCRO etc.).\nValid values are:\n  - \"pro\": Update a Process Result Object\n  - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.\n  - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.\n",
            "name": "checkClass",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["pro", "bcro", "fraudlist"]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CheckResultUpdateObject"
              }
            }
          },
          "description": "The check result status change details to apply",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckEntityCheckResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/check/{checkId}/{checkClass}/{checkClassId}": {
      "post": {
        "description": "Internal only\n\nUpdate a given KYC or AML check result status in order to force a re-evaluation of the overall check result.\n",
        "tags": ["Entity"],
        "summary": "Update Check Result State",
        "operationId": "UpdateCheckClassResult",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "The checkId returned previously from an earlier call to */verify",
            "name": "checkId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Specify which check Class this action will apply to (PRO, BCRO etc.).\nValid values are:\n  - \"pro\": Update a Process Result Object\n  - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.\n  - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.\n",
            "name": "checkClass",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["pro", "bcro", "fraudlist"]
            }
          },
          {
            "description": "A PRO/BCRO ID\n",
            "name": "checkClassId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Set the new status of the Check Class (PRO/BCRO).\nValid values are:\n  - \"unknown\"\n  - \"true_positive\"\n  - \"true_positive_accept\"\n  - \"true_positive_reject\"\n  - \"false_positive\"\n  - \"stale\"\n",
            "name": "status",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Undo a prior operation.\n",
            "name": "undo",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckEntityCheckResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/checks": {
      "get": {
        "description": "Get the complete list of all checks that have been performed upon a given entity and its documents, including the checks that have been performed by others (in those cases you just get the id, status and date run, none of the details).\n",
        "tags": ["Entity"],
        "summary": "Retrieve Entity Verification Check Details\n",
        "operationId": "QueryEntityChecks",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Requests that all check data (including historic) should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile.\n\nNote: When allData is set to true the risk and summary data of the entity are excluded as this information does not make sense in the context of a response that can include overridden and ignored check data.\n",
            "name": "alldata",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Poll for the given result type until a result is found (whether pass or fail) or the timeout (see below) is reached. If timeout is reached, a 404 will be returned.\n",
            "name": "awaitResult",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Timeout in seconds to poll for a result. Ignored if awaitResult parameter is not supplied. Defaults to 30 seconds if not supplied. Minimum of 1 second and maximum of 60 seconds is allowed.\n",
            "name": "timeout",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckEntityCheckResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/evaluate": {
      "post": {
        "description": "This does everything an UpdateCheckEntity operation does, except actually verifying anything new.\n\nThe entity update details are optional so the request body can be empty. If the body is given, then it must\ncontain an EntityCheckDetailsObject like a normal UpdateCheckEntity operation, and the entity in the body must\nhave the same entity ID as in the URL.\n\nThe result returned is equivalent to the summary result for the UpdateCheckEntity operation.\n",
        "tags": ["Entity"],
        "summary": "Update Entity and evaluate current results and risk without running any new checks",
        "operationId": "UpdateEvaluateEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Disable check result invalidation for this update request.\n",
            "name": "noInvalidate",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Disable notifications for this request.\n",
            "name": "noNotify",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityCheckDetailsObject"
              }
            }
          },
          "description": "The entity details to be updated before evaluating the results"
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckEntityCheckResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/flag/blacklist": {
      "post": {
        "description": "Mark the entity as blacklisted or not with the '?set=' query parameter as 'true' or 'false'.\n",
        "tags": ["Flag"],
        "summary": "Set Entity Blacklist State.",
        "operationId": "BlacklistEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Set the value of an entity flag.\n",
            "name": "set",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Set the reason for blacklisting.\nValid values are:\n  - \"NO_REASON_SUPPLIED\"\n  - \"FABRICATED_IDENTITY\"\n  - \"IDENTITY_TAKEOVER\"\n  - \"FALSIFIED_ID_DOCUMENTS\"\n  - \"STOLEN_ID_DOCUMENTS\"\n  - \"MERCHANT_FRAUD\"\n  - \"NEVER_PAY_BUST_OUT\"\n  - \"CONFLICTING_DATA_PROVIDED\"\n  - \"MONEY_MULE\"\n  - \"FALSE_FRAUD_CLAIM\"\n  - \"FRAUDULENT_3RD_PARTY\"\n  - \"COMPANY_TAKEOVER\"\n  - \"FICTITIOUS_EMPLOYER\"\n  - \"COLLUSIVE_EMPLOYER\"\n  - \"OVER_VALUATION_OF_ASSETS\"\n  - \"FALSIFIED_EMPLOYMENT_DETAILS\"\n  - \"MANIPULATED_IDENTITY\"\n  - \"SYNDICATED_FRAUD\"\n  - \"INTERNAL_FRAUD\"\n  - \"BANK_FRAUD\"\n  - \"UNDISCLOSED_DATA\"\n  - \"FALSE_HARDSHIP\"\n  - \"SMR_REPORT_LODGED\"\n  - \"2X_SMR_REPORTS_LODGED\"\n  - \"CUSTOMER_REQUEST\"\n  - \"ABUSIVE_CUSTOMER\"\n",
            "name": "reason",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specify who is setting the entity as blacklisted.\n",
            "name": "blockedBy",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specify the blacklisted attribute.\nValid values are:\n  - \"ENTIRE_PROFILE\"\n  - \"FULL_NAME\"\n  - \"EMAIL_ADDRESS\"\n  - \"PHONE_NUMBER\"\n  - \"ID_DOCUMENT\"\n  - \"MAILING_ADDRESS\"\n  - \"RESIDENTIAL_ADDRESS\"\n",
            "name": "attribute",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Specify the Id of the matching blacklisted entity or single data-point.\n",
            "name": "originalId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/flag/duplicate/{otherId}": {
      "post": {
        "description": "Resolve the state of a pair of duplicate entities with the '?set=' query parameter as 'true' or 'false'.\nSetting duplicate to 'true' will make entityId invisible for most purposes and otherId will continue to function as normal.\nSetting duplicate to 'false' means the two entities are in fact separate but similar and they will both continue to exist independently but will no longer be identified as duplicates of each other.\n",
        "tags": ["Flag"],
        "summary": "Resolve Duplicate States.",
        "operationId": "FlagDuplicateEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds",
            "name": "otherId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Set the value of an entity flag.\n",
            "name": "set",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/flag/monitor": {
      "post": {
        "description": "Mark the entity as being monitored or not with the '?set=' query parameter as 'true' or 'false'.\nSetting this parameter to 'true' will disable ongoing monitoring.\nSetting this parameter to 'false' will enable ongoing monitoring.\n",
        "tags": ["Flag"],
        "summary": "Set Entity Ongoing AML Monitoring Status.",
        "operationId": "EntityMonitoring",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Set the value of an entity flag.\n",
            "name": "set",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/flag/watchlist": {
      "post": {
        "description": "Mark the entity as watchlisted or not with the '?set=' query parameter as 'true' or 'false'.\n",
        "tags": ["Flag"],
        "summary": "Set Entity Watchlist State.",
        "operationId": "WatchlistEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Set the value of an entity flag.\n",
            "name": "set",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Set the reason for watchlisting.\nValid values are:\n - \"WAS_BLACKLISTED\"\n",
            "name": "reason",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A comment describing the reason for a request.\n",
            "name": "comment",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/full": {
      "get": {
        "description": "Query the current status and details of a given entityId. Also returns all attached document file data, not just the metadata. Equivalent to a get /document/{documentId}/full)\n",
        "tags": ["Entity"],
        "summary": "Retrieve Entity Details and Document Scan Data\n",
        "operationId": "QueryEntityFull",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Optionally include child accounts in your search\n",
            "name": "child",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/idvalidate/getToken": {
      "post": {
        "description": "Update an entity object and if successful, obtain a token for use in an ID Validation service SDK (web or native app) \n\nAt a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling the initProcess function.\n\nSPECIAL NOTE 1: Tokens have a limited lifespan, typically only 1 hour. Make sure you've used it or you will need to create another using update version of this function. \n\nSPECIAL NOTE 2: This function will need to be followed up with a call to /entity/{id}/idvalidate/initProcess once you've collected all your data in your app/web capture process.\n",
        "tags": ["Entity"],
        "summary": "Update Entity and Get IDV Token",
        "operationId": "UpdateEntityGetIDVToken",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityIDVDetailsObject"
              }
            }
          },
          "description": "The entity to update and required data to generate an IDV token",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.\n\nAlso returned is the applicantId and token to be in the IDV process.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityIDVResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/idvalidate/initProcess": {
      "post": {
        "description": "Update an entity object and if successful, start the process of downloading the captured data and processing the reports and results of the ID validation process. \n\nAt a minimum, the entity will need to have a name. For best results, you should gather the DoB, address, ID document details as well before calling this initProcess function, or supply the details as part of this update.\n\nThe IDV process may run various checks against the photos and videos supplied by the applicant.\n\nThese check types are configured on request and can include:\n\n>- ID Validation (Document) - Looks at the picture(s) of the identity document, and does checks about image quality, as well as specific things about the id itself, such as whether it is expired or is for someone under 18. The image is also OCR'd and the OCR results are compared against the data entered for any KYC checks to make sure that it is the same document.\n\n>- Facial Photo Comparison - Compares the portrait picture of the identity document, to the selfie taken as part of the idv process. The selfie can be either a still photo or a live video (preferred). This checks both that the selfie taken is valid and not manipulated, and that it is a reasonable match to the picture on the identity document. The exact algorithm to determine matches and quality is dependant on the provider chosen.\n\n>- Facial Duplicate - Compares the selfie provided with previous selfies for other applicants. This check type is trying to identify based on the selfie whether this applicant has already registered under a different name and potentially with faked identification. If there is a potential match then the applicant is flagged for review.\n",
        "tags": ["Entity"],
        "summary": "Update Entity and Initiate IDV Process",
        "operationId": "UpdateEntityInitIDVProcess",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityCheckDetailsObject"
              }
            }
          },
          "description": "The entity to update",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.\n\nAlso returned is the applicantId and token to be in the IDV process.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityIDVResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/report": {
      "post": {
        "description": "## (**ALPHA**): This endpoint is in alpha.\n\nGenerate an Individual Verification Report for an entity. The report contains all the latest personal information and the check results ran on the entity.\n\nYou can generate the report in two ways:\n\nAsynchronous: You receive a requestID in the response. Once the PDF is generated, a notification will be sent to your web-hook endpoint. The notification includes a downloadable URL.\nMore info on the web-hook set up here: https://docs.frankieone.com/docs/notifications-webhooks.\n\nSynchronous: Once the PDF is generated, you will receive a downloadable link in the response.\n\nPlease note, the link expires after a configurable time.\nEither way, the generated report is also attached to the entity as a document object under idType kyc-report. The scanData is a base64 encoded blob.\n",
        "tags": ["Entity"],
        "summary": "Generate Individual Verification Report",
        "operationId": "EntityKycReport",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityReportResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/status": {
      "post": {
        "description": "Internal only\n\nAdd a special internal 'entity result' to superceed any previous real checks until the next one.\n",
        "tags": ["Entity"],
        "summary": "Update Entity States",
        "operationId": "UpdateEntityState",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "The status of an entity.\nValid values are:\n  - \"wait\": Waiting for new details from entity.\n  - \"fail\": Manually fail the onboarding process.\n  - \"pass\": Manually pass the entity. Only allowed if entity is already actually passed.\n  - \"refer\": Set the entity onboarding as needing attention.\n  - \"archived\": Hide entity from on onboarding.\n  - \"clear\": Remove any of the above manual states as well as any manual risk.\n  - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared.\n",
            "name": "set",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "wait",
                "fail",
                "pass",
                "refer",
                "archived",
                "clear",
                "inactive"
              ]
            }
          },
          {
            "description": "The risk override setting for an entity. This value will be used until a verify result updates a real risk factor.\nValid values are:\n  - \"low\"\n  - \"medium\"\n  - \"high\"\n  - \"unacceptable\"\n  - \"significant\"\n",
            "name": "risk",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": ["low", "medium", "high", "unacceptable", "significant"]
            }
          },
          {
            "description": "A comment describing the reason for a request.\n",
            "name": "comment",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckEntityCheckResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/verify/pushToMobile": {
      "post": {
        "description": "Update an existing entity object and begin the process of verification after pushing a message to a mobile number. \nThe entity will receive a link on their mobile and will then be guided through a series of steps to capture and OCR scan their ID, and perform a selfie comparison. We'll then attempt to verify the data received and push a notification back to the calling customer.\n\nAt a minimum, you will need to supply the name and a MOBILE_PHONE document type.        \nIf you wish to skip the detail capture and jump straight to the ID and selfie capture, the append the call with the ?phase=2 parameter.\n\n\nSPECIAL NOTE: This will only ever return a 202 response if successfully accepted. You will need to ensure your account is configured for push notifications. Contact developer supprt to arrange this.\n",
        "tags": ["Entity"],
        "summary": "Update Entity and Push Self-Verification Link",
        "operationId": "UpdateCheckEntityPushToMobile",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "Set the Push To Mobile phase.\n\nCurrently supported values:\n- 2\n",
            "name": "phase",
            "in": "query",
            "schema": {
              "type": "integer"
            }
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/EntityCheckDetailsObject"
        },
        "responses": {
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/entity/{entityId}/verify/{checkType}/{resultLevel}": {
      "post": {
        "description": "Take the details and documents provided in the entity, and set about verifying them all.\nSo for example, you might extract:\n\n* The name from the entity.name object\n* The address from the entity.address object\n* The DoB..\n\nAll documents that are presently attached to the entity will also be verified (if requested)\n\nYou can also specify the level of detail returned using the resultLevel parameter. You can choose \"summary\" or \"full\". For the \"profile\" check type you can also select \"simple\" to only get the entity profile result.\n\nSPECIAL NOTE: A \"Full\" response includes details of all checks and how they map against each element, along with all the details of pep/sanctions/etc checks too.\n\nYour account also needs to be configured to support a full response too (talk to your account manager for more information). If you're not configured for full responses, we'll only return summary level data regardless.\n",
        "tags": ["Entity"],
        "summary": "Update Entity and Verify Details",
        "operationId": "UpdateCheckEntity",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If this header parameter is supplied and set to 1, then the request will not wait for the process to finish, and will return a 202 if there are no obvious errors in the input. The request will then run in the background and send a notification back to the customer. See out callback API for details on this.\n\nSee more details here:\n  https://docs.frankieone.com/docs/asynchronous-calls-backgrounding-processes\n",
            "name": "X-Frankie-Background",
            "in": "header",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 1
            }
          },
          {
            "description": "Open string that can be used to define the \"channel\" the request comes in from.\nIt can potentially be used in routing and risk calculations upon request.\nDefault values that can be used are:\n  - api\n  - portal\n  - smartui\n\nAny alphanumeric string is supported though. Anything over 64 characters will be truncated.\n",
            "name": "X-Frankie-Channel",
            "in": "header",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The entityId returned previously from an earlier call to /check or /entity",
            "name": "entityId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "When creating a new check, you need to define the checks you wish to run.\n  \nThe checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.\n\n  The validation that is performed on the requested checks is to:\n  - ensure the check type is known\n  - is suitable for the type of entity (no KYC for organisations)\n  - disallow manual (mKYC) check with any other kind of KYC\n  - disallow mixing the \"profile\" check with any other kind of check.\n\nThe supported check types are:\n\nProfile:\n  - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.\n  \n  The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.\n  \n  Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.\n  They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.\n  \n  Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.\n\n**Individual Check Types**\n\nWhilst we strongly recommend the use of the \"profile\" checktype, it does map to any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.\n\nEntity Checks - One of:\n  - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)\n  - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)\n\nID Checks - One of:\n  - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.\n  - \"visa\":\n  \nID Validate - One of:\n  - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.\n  \nManual Check:\n  - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.\n  \nFraud Checks - One or more of:\n  - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.\n  - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)\n  \nPEP Checks - One of:\n  - \"pep\": Will only run PEP/Sanctions checks (no identity verification)\n  - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)\n  \n  * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.\n\nDevice checks:\n  - \"device\": This will allow you to pass in device details captured through services like ThreatMetrix or Sardine.ai\n\nCustom:\n  - By arrangement with Frankie you can define your own KYC check type.\n  \n  This will allow you to set the minimum number of matches for:\n    - name \n    - date of birth\n    - address\n    - government id\n  \n  This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). \n  Speak with the Customer Success team when you're onboarding.\n",
            "name": "checkType",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "profile"
            }
          },
          {
            "description": "How much detail we return. \n\nAcceptable values are:\n  * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.\n  * summary\n  * full - You need to have your account configured for this.\n",
            "name": "resultLevel",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": ["simple", "summary", "full"]
            }
          },
          {
            "description": "Force the verification to run, overriding any data aging or past check\n",
            "name": "force",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Disable check result invalidation for this update request.\n",
            "name": "noInvalidate",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityCheckDetailsObject"
              }
            }
          },
          "description": "The entity to be checked",
          "required": true
        },
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CheckEntityCheckResultObject"
                }
              }
            }
          },
          "202": {
            "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedEntityResultObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "405": {
            "description": "A request to POST an update to an object was not allowed due to it's state. This may indicate an already completed check, or a document that has been processed. You need to create a new document/check if you wish to update the object in question.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "415": {
            "description": "For requests with payloads, an unsupported Content-Type was specified. The Frankie Financial API only supports a content type of application/json.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "422": {
            "description": "Unprocessable request. This can be triggered in a number of ways.\n* An attempt to force a check or scan to run, but there is insufficient data to be able to do so.\n* An attempt to run a document/entity specific scan or process on an unsupported document type (e.g. electricity comparison on a passport)\nDetails of what is required will be in the issues list of the error response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "429": {
            "description": "The API client is making too many concurrent requests, and some are being throttled. Throttled requests can be retried after a short delay.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "503": {
            "description": "All of the ID sources configured by the customer are unavailable, or there is no available document processor.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/retrieve/response/{requestId}": {
      "get": {
        "description": "If you've received a notification that you previously backgrounded transaction has completed, or you wish to re-retrive a result from an earlier transaction, then you can simply request the result from our encrypted cache\n\nThe response will return the original HTTP code, along with the payload that would have been returned in the original request. The data can be re-retrieved for a maximum of 3 days.\n",
        "tags": ["Retrieve"],
        "summary": "(Re)retrieve Response Result.",
        "operationId": "RetrieveResult",
        "parameters": [
          {
            "description": "Customer ID issued by Frankie Financial. This will never change. Your API key, which is mapped to this identity, will change over time.\n",
            "name": "X-Frankie-CustomerID",
            "in": "header",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "If, as a Frankie Customer, you are acting on behalf of your own customers, then you can populate this field with a Frankie-assigned ID.\n\nNote: If using a CustomerChildID, you will also need a separate api_key for each child.\n\nAny documents, checks, entities that are created when this field has been populated will now be tied to this CustomerID + CustomerChildID combination. Just as Customers cannot see data created by other Customers, so too a Customer's Children will not be able to see each other's data.\n\nA Customer can see the documents/entities and checks of all their Children.\n",
            "name": "X-Frankie-CustomerChildID",
            "in": "header",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "description": "This will be the same RequestId that was sent in the 202 acceptance response.\n",
            "name": "requestId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "description": "Specifies the type of the payload field in the retrieved response. Default is 'string'.\n",
            "name": "payload",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": ["string", "object"]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RetrievedResponseObject"
                }
              }
            }
          },
          "400": {
            "description": "Bad request. One or more request fields is either missing or incorrect. Details are in the error response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "401": {
            "description": "The request has failed an authorisation check. This can happen for a variety of reasons, such as an invalid or expired API key, or invalid Customer/CustomerChildIDs. \n* NOTE: This does not include attempts to read/write data you don't have access to - that's a 404 error (as we don't want to leak information through guessing)\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "404": {
            "description": "Cannot return response. In the case of a query, or reference to a specific entity/check/etc, it means that the requested item was not found, or you don't have access to it. Please check your query before trying again.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          },
          "500": {
            "description": "Unexpected error. Something went wrong during the checking process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/ruok": {
      "get": {
        "security": [],
        "description": "Simple check to see if the service is running smoothly.",
        "tags": ["Status"],
        "summary": "Service Status",
        "operationId": "StatusCheck",
        "parameters": [
          {
            "description": "If set to true, the request is being made politely.\n",
            "name": "askingNicely",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The system is fine. No issues, and everyone gets a puppy. But only if a Customer ID is supplied, otherwise, no puppy for you. Also, try asking nicely.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PuppyObject"
                }
              }
            }
          },
          "500": {
            "description": "The system is presently unavailable, or running in a severely degraded state. Check the error message for details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorObject"
                }
              }
            }
          }
        }
      }
    },
    "/your/configured/path/{requestId}": {
      "post": {
        "security": [],
        "description": "Whenever you request that a transaction be put into the background, there needs to be a mechanism for notifying you that the request has been completed. This notification will push you the high-level details of the result, and you can then query the results at your leisure.\n\nThe same notification process will also be used to push alerts to your system. This means that RequestIDs may not match your records\n",
        "tags": ["Push Notification"],
        "summary": "Push Notification Payload",
        "operationId": "notifyResult",
        "parameters": [
          {
            "description": "This will be the same RequestId that was sent in the 202 acceptance response.\n",
            "name": "requestId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NotificationResultObject"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The Customer has accepted the notification and we don't need to retry sending it."
          },
          "400": {
            "description": "The notification represents a type of notification the customer was not expecting, or can accept. No retry."
          },
          "500": {
            "description": "The Customer cannot accept the notification at this time. Please resend again later"
          }
        }
      }
    }
  },
  "security": [
    {
      "api_key": []
    }
  ],
  "tags": [
    {
      "description": "Service status functions you can use to make sure things are up and running.",
      "name": "Status"
    },
    {
      "description": "Operations on specific ID documents, specific to an entity (people).",
      "name": "Document"
    },
    {
      "description": "Operations on specific entities (people / companies / etc)",
      "name": "Entity"
    },
    {
      "description": "Operations on entities that are set to type ORGANISATION",
      "name": "Business"
    },
    {
      "description": "These are callback/webhook functions. If you've requested a callback, this will be what is sent to you. You do not need to implement these as a client, but you do need to be able to accept them as a server.",
      "name": "Push Notification"
    },
    {
      "description": "Functions used for retrieving past results",
      "name": "Retrieve"
    },
    {
      "description": "Operations on entities to set specific flags and states.",
      "name": "Flag"
    }
  ],
  "servers": [
    {
      "url": "https://api.uat.frankie.one/compliance/v1.2"
    }
  ],
  "components": {
    "parameters": {
      "AlertIDPathParameter": {
        "description": "The alertId that was passed to you in a previous notification",
        "name": "alertId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "AllDataQueryParameter": {
        "description": "Requests that all check data (including historic) should be included in the response to a \"get checks\" request. This is as opposed to a filtered view where expired results are by default not included for entities that have an assigned profile.\n\nNote: When allData is set to true the risk and summary data of the entity are excluded as this information does not make sense in the context of a response that can include overridden and ignored check data.\n",
        "name": "alldata",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "AskingNicelyQueryParameter": {
        "description": "If set to true, the request is being made politely.\n",
        "name": "askingNicely",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "AttributeQueryParameter": {
        "description": "Specify the blacklisted attribute.\nValid values are:\n  - \"ENTIRE_PROFILE\"\n  - \"FULL_NAME\"\n  - \"EMAIL_ADDRESS\"\n  - \"PHONE_NUMBER\"\n  - \"ID_DOCUMENT\"\n  - \"MAILING_ADDRESS\"\n  - \"RESIDENTIAL_ADDRESS\"\n",
        "name": "attribute",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "AwaitResultParameter": {
        "description": "Poll for the given result type until a result is found (whether pass or fail) or the timeout (see below) is reached. If timeout is reached, a 404 will be returned.\n",
        "name": "awaitResult",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "BlockedByQueryParameter": {
        "description": "Specify who is setting the entity as blacklisted.\n",
        "name": "blockedBy",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "BlocklistsQueryParameter": {
        "description": "Specify the blacklisted attribute.\n",
        "name": "blockLists",
        "in": "query",
        "style": "form",
        "explode": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "BusinessCheckResultLevelQueryParameter": {
        "description": "The result level allows you to specify the level of detail returned for the entity check. You can choose summary or full.\n",
        "name": "resultLevel",
        "in": "query",
        "schema": {
          "type": "string",
          "enum": ["summary", "full"],
          "default": "summary"
        }
      },
      "BusinessCheckTypeQueryParameter": {
        "description": "When creating a new check, we need to define the checks we wish to run. If this parameter is not supplied then the check will be based on a configured check type for each entity category.\n  \nThe checkType is make up of a comma separated list of the types of check we wish to run.\n\nThe order is important, and must be of the form:\n  - Entity Check (if you're running this). Choose one from the available options\n  - ID Check (If you want this)\n  - PEP Checks (again if you want this, choose one of the options)\n\nEntity Checks - One of:\n  - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)\n  - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)\n\nID Checks - One of:\n  - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.\n  \nFraud Checks - One or more  of:\n  - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.\n  - \"fraudid\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)\n  \nPEP Checks - One of:\n  - \"pep\": Will only run PEP/Sanctions checks (no identity verification)\n  - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)\n  \n  * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.\n\nPre-defined combinations (deprecated):\n  - \"full\": equivalent to \"two_plus,id,pep_media\" or \"pep_media\" if the target is an organisation.\n  - \"default\": Currently defined as \"two_plus,id\" or \"pep\" if the target is an organisation.\n\n  * NOTE: These options are now deprecated and support for these options will be eventually halted. Please specify check_types explicitly.\n  \nCustom:\n  - By arrangement with Frankie you can define your own KYC check type.\n  \n  This will allow you to set the minimum number of matches for:\n    - name \n    - date of birth\n    - address\n    - government id\n  \n  This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too).\n  \nProfile:\n  - \"profile\": By arrangement with Frankie you can have a \"profile\" check type that applies checks according to a profile that you assign to the entity from a predefined set of profiles.\n  \n  The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.\n  \n  Profiles act a little like the Pre-defined combinations above in that they can map to a defined list. But they offer a lot more besides, including rules for determining default settings, inbuild data aging and other configurable features.\n  They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.\n  \n  Entity Profiles are the future of checks with Frankie Financial.\n",
        "name": "checkType",
        "in": "query",
        "style": "form",
        "explode": false,
        "schema": {
          "type": "array",
          "items": {
            "enum": [
              "one_plus",
              "two_plus",
              "id",
              "fraudlist",
              "fraudcheck",
              "pep",
              "pep_media",
              "profile",
              "full",
              "default"
            ],
            "type": "string"
          },
          "uniqueItems": true
        }
      },
      "BusinessEntityCategoriesQueryParameter": {
        "description": "A comma separated list that specifies the categories of entities associated with the target organisation that will be checked.\n\n  - organisation - Just the organisation itself.\n  - ubos - All ultimate beneficial owners.\n  - pseudo_ubos - Use an alternative category when an organisation has no actual UBOs. The actual category to use is defined via configuration, default is no alternative category.\n  - nibos - Non-Individual Beneficial Owners\n  - bos_associated - Beneficial owners that have been manually associated, rather than retrieved from registry sources\n  - direct_owners - All direct owners of the company, both organisations and individuals, may include UBOs for for simple ownership.\n  - officers - All officers of the company\n  - officers_directors - All directors of the company\n  - officers_secretaries - All secretaries of the company\n  - officers_other - All non-director officers of the company\n  - officers_associated - All officers of the company that were associated manually, rather than retrieved from registry sources\n  - all - All direct and indirect owners, both organisations and individuals (including UBOs), and officers of all organisations.\n",
        "name": "entityCategories",
        "in": "query",
        "style": "form",
        "explode": false,
        "schema": {
          "type": "array",
          "items": {
            "enum": [
              "organisation",
              "ubos",
              "pseudo_ubos",
              "nibos",
              "bos_associated",
              "direct_owners",
              "officers",
              "officers_directors",
              "officers_secretaries",
              "officers_other",
              "officers_associated",
              "all"
            ],
            "type": "string"
          },
          "uniqueItems": true
        }
      },
      "BusinessGenerateReportQueryParameter": {
        "description": "The type of human readable report, if any, to generate based on the ownership query results.\nOptions are:\n  - SINGLE-LEVEL-AML: ASIC report\n  - UBO: UBO report\n",
        "name": "generateReport",
        "in": "query",
        "schema": {
          "type": "string",
          "enum": ["SINGLE-LEVEL-AML", "UBO"]
        }
      },
      "BusinessIncludeHistoricalQueryParameter": {
        "description": "If set to true, historical ownership data will be requested.\n",
        "name": "includeHistorical",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "BusinessInternationalEntityIDPathParameter": {
        "description": "The entityId of a business entity returned by a successful call to /business/international/profile",
        "name": "entityId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "BusinessInternationalRequestIDQueryParameter": {
        "description": "The requestId that was received when ordering a report. Do not pass this to retrieve all document order statuses for the entity",
        "name": "requestId",
        "in": "query",
        "schema": {
          "type": "string",
          "format": "ulid"
        }
      },
      "BusinessNoLoadQueryParameter": {
        "description": "Do not load the named result objects from cache, but force them to be retrieved from an approproate service, if and when they are required.\nOptions are:\n- abr\n- ownership\n",
        "name": "noLoad",
        "in": "query",
        "style": "form",
        "explode": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "uniqueItems": true
        }
      },
      "BusinessOnlyProfileQueryParameter": {
        "description": "If set to true, a full UBO report will not be requested.\nNote: This param is deprecated, use ownershipMode instead.\n",
        "name": "onlyProfile",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "BusinessOwnershipModeQueryParameter": {
        "description": "Define the ownership mode you wish to run.\n\nValid ownership modes are:\n  - full\n  - onlyProfile\n  - onlyUBO\n",
        "name": "ownershipMode",
        "in": "query",
        "schema": {
          "type": "string",
          "enum": ["full", "onlyProfile", "onlyUBO"]
        }
      },
      "BusinessPresetQueryParameter": {
        "description": "Name of configured preset query parameters to use. Any individual parameters provided in the\nrequest will override the same parameter in the configured preset.\n",
        "name": "preset",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "BusinessReportPDFQueryParameter": {
        "description": "Should the report(s) also be generated as a PDF document.\n",
        "name": "pdf",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "BusinessReportTypesQueryParameter": {
        "description": "Define the report(s) you wish to run.\n\nYou can request more than one as a comma separated list. \nDuplicates will be ignored.\n\nNote: These reports are different to the business details and UBO queries and are meant to provide deeper detail and background on a business or organisation.\n  \nCurrent valid report types are:\n  - creditScore\n  - creditReport\n  - paymentPredictor\n",
        "name": "reportTypes",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "BusinessValidationParameter": {
        "description": "Should a validation check be run before the ownership query. The default is specified via configuration. The validation checks to see if the provided organisation is suitable for an ownership query by looking for the ACN in public data sources. \nOptions are:\n- \"on\": Validate only when ACN is not provided. This is the typical default.\n- \"acn\": Validate even if ACN is provided.\n- \"only\": Like \"acn\" but only do validation query, don't proceed with ownership query. This option cannot be set as the default via configuration.\n- \"off\": Never validate. The Ownership query will then fail if an ACN is not provided.\n",
        "name": "validation",
        "in": "query",
        "schema": {
          "type": "string",
          "enum": ["on", "off", "only", "acn"]
        }
      },
      "CheckClassActionQueryParameter": {
        "description": "Set the new status of the Check Class (PRO/BCRO).\nValid values are:\n  - \"unknown\"\n  - \"true_positive\"\n  - \"true_positive_accept\"\n  - \"true_positive_reject\"\n  - \"false_positive\"\n  - \"stale\"\n",
        "name": "status",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "CheckClassIDPathParameter": {
        "description": "A PRO/BCRO ID\n",
        "name": "checkClassId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "CheckClassPathParameter": {
        "description": "Specify which check Class this action will apply to (PRO, BCRO etc.).\nValid values are:\n  - \"pro\": Update a Process Result Object\n  - \"bcro\": Update a Background Check Result Object. The class IDs in the request must be the IDs from Background Check Result Object Containers.\n  - \"fraudlist\": Update a fraud list Process Result Object. The class IDs in the request must be check sources from fraudlist Process Result Objects.\n",
        "name": "checkClass",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "enum": ["pro", "bcro", "fraudlist"]
        }
      },
      "CheckIDPathParameter": {
        "description": "The checkId returned previously from an earlier call to */verify",
        "name": "checkId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "CheckTypeParameter": {
        "description": "When creating a new check, you need to define the checks you wish to run.\n  \nThe checkType is make up of a comma separated list of the types of check you wish to run. The order of the requested checks is not important, they will be re-ordered by the service and in some cases, depending on your account configuration, may be skipped.\n\n  The validation that is performed on the requested checks is to:\n  - ensure the check type is known\n  - is suitable for the type of entity (no KYC for organisations)\n  - disallow manual (mKYC) check with any other kind of KYC\n  - disallow mixing the \"profile\" check with any other kind of check.\n\nThe supported check types are:\n\nProfile:\n  - \"profile\": By arrangement with Frankie we will create a \"profile\" check type that applies checks according to a recipe that you assign to the entity from a predefined set of profiles.\n  \n  The profile to use will be taken from the entity.entityProfile field if set, or be run through a set of configurable rules to determine which one to use.\n  \n  Profiles provide a pre-defined combination of individual checkTypes (see the list below). But they offer a lot more besides, including rules for determining default settings, inbuilt data aging and other configurable features.\n  They also allow for a new result set top be returned that provides a more detailed and useful breakdown of the check/verification process.\n  \n  Entity Profiles are a recent feature (since v1.4.0) but are now the default checkType to use with Frankie Financial.\n\n**Individual Check Types**\n\nWhilst we strongly recommend the use of the \"profile\" checktype, it does map to any combination of the types below. If you wish to use these individually, please contact developer support for more details on how to use these effectively.\n\nEntity Checks - One of:\n  - \"one_plus\": Checks name, address and DoB against a minimum of 1 data source. (also known as a 1+1)\n  - \"two_plus\": Checks name, address and DoB against a minimum of 2 independent data sources (also known as a 2+2)\n\nID Checks - One of:\n  - \"id\": Checks all of the identity documents, but not necessarily the entity itself independently. Use this in conjunction with a one_plus or two_plus for more.\n  - \"visa\":\n  \nID Validate - One of:\n  - \"idvalidate\": Checks to see if photo ID has had OCR scanning, ID document validation and photo comparison run against it. Can be used in conjunction with any of the KYC/ID/AML checks.\n  \nManual Check:\n  - \"manual\": (mKYC) Checks user has a sufficient amount of operator verified ID and will then \"pass\" all Entity and ID related checks.\n  \nFraud Checks - One or more of:\n  - \"fraudlist\": Checks to see if the identity appears on any known fraud lists. Should be run after KYC/ID checks have passed.\n  - \"fraudcheck\": Checks external ID services to see if details appear in fraud detection services (e.g. EmailAge or FraudNet)\n  \nPEP Checks - One of:\n  - \"pep\": Will only run PEP/Sanctions checks (no identity verification)\n  - \"pep_media\": Will run PEP/Sanctions checks, as well as watchlist and adverse media checks. (no identity verification)\n  \n  * NOTE: These checks will ONLY run if either the KYC/ID checks have been run prior, or it is the only check requested.\n\nDevice checks:\n  - \"device\": This will allow you to pass in device details captured through services like ThreatMetrix or Sardine.ai\n\nCustom:\n  - By arrangement with Frankie you can define your own KYC check type.\n  \n  This will allow you to set the minimum number of matches for:\n    - name \n    - date of birth\n    - address\n    - government id\n  \n  This allows for alternatives to the \"standard\" two_plus or one_plus (note, these can be overridden too). \n  Speak with the Customer Success team when you're onboarding.\n",
        "name": "checkType",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "default": "profile"
        }
      },
      "CommentQueryParameter": {
        "description": "A comment describing the reason for a request.\n",
        "name": "comment",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "DocumentIDPathParameter": {
        "description": "The documentId returned previously from an earlier call to /check or /entity or /document",
        "name": "documentId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "EntityIDPathParameter": {
        "description": "The entityId returned previously from an earlier call to /check or /entity",
        "name": "entityId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "EntityRiskQueryParameter": {
        "description": "The risk override setting for an entity. This value will be used until a verify result updates a real risk factor.\nValid values are:\n  - \"low\"\n  - \"medium\"\n  - \"high\"\n  - \"unacceptable\"\n  - \"significant\"\n",
        "name": "risk",
        "in": "query",
        "schema": {
          "type": "string",
          "enum": ["low", "medium", "high", "unacceptable", "significant"]
        }
      },
      "ForceFlagQueryParameter": {
        "description": "Force the verification to run, overriding any data aging or past check\n",
        "name": "force",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "IncludeChildPathParameter": {
        "description": "Optionally include child accounts in your search\n",
        "name": "child",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "NoInvalidateQueryParameter": {
        "description": "Disable check result invalidation for this update request.\n",
        "name": "noInvalidate",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "NoNotifyQueryParameter": {
        "description": "Disable notifications for this request.\n",
        "name": "noNotify",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "NotificationIDPathParameter": {
        "description": "This is a Customer/ChildCustomer specific ID (UUID) that is used to help identify Frankie as a known notifying service. This ID is configured on the Frankie side along with the rest of the customer path as the endpoint for us to push notifications to.",
        "name": "notificationId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "OnlyEntityIDsQueryParameter": {
        "description": "Only include entity IDs in the search results, not whole entities\n",
        "name": "onlyEntityIds",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      },
      "OriginalIdQueryParameter": {
        "description": "Specify the Id of the matching blacklisted entity or single data-point.\n",
        "name": "originalId",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "OtherIDPathParameter": {
        "description": "An entityId returned previously from an earlier call to /check or /entity. Used when an operation requires two entityIds",
        "name": "otherId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "format": "uuid"
        }
      },
      "PTMPhaseQueryParameter": {
        "description": "Set the Push To Mobile phase.\n\nCurrently supported values:\n- 2\n",
        "name": "phase",
        "in": "query",
        "schema": {
          "type": "integer"
        }
      },
      "PayloadEncodingQueryParameter": {
        "description": "Specifies the type of the payload field in the retrieved response. Default is 'string'.\n",
        "name": "payload",
        "in": "query",
        "schema": {
          "type": "string",
          "enum": ["string", "object"]
        }
      },
      "ReasonFlagQueryParameter": {
        "description": "Set the reason for blacklisting.\nValid values are:\n  - \"NO_REASON_SUPPLIED\"\n  - \"FABRICATED_IDENTITY\"\n  - \"IDENTITY_TAKEOVER\"\n  - \"FALSIFIED_ID_DOCUMENTS\"\n  - \"STOLEN_ID_DOCUMENTS\"\n  - \"MERCHANT_FRAUD\"\n  - \"NEVER_PAY_BUST_OUT\"\n  - \"CONFLICTING_DATA_PROVIDED\"\n  - \"MONEY_MULE\"\n  - \"FALSE_FRAUD_CLAIM\"\n  - \"FRAUDULENT_3RD_PARTY\"\n  - \"COMPANY_TAKEOVER\"\n  - \"FICTITIOUS_EMPLOYER\"\n  - \"COLLUSIVE_EMPLOYER\"\n  - \"OVER_VALUATION_OF_ASSETS\"\n  - \"FALSIFIED_EMPLOYMENT_DETAILS\"\n  - \"MANIPULATED_IDENTITY\"\n  - \"SYNDICATED_FRAUD\"\n  - \"INTERNAL_FRAUD\"\n  - \"BANK_FRAUD\"\n  - \"UNDISCLOSED_DATA\"\n  - \"FALSE_HARDSHIP\"\n  - \"SMR_REPORT_LODGED\"\n  - \"2X_SMR_REPORTS_LODGED\"\n  - \"CUSTOMER_REQUEST\"\n  - \"ABUSIVE_CUSTOMER\"\n",
        "name": "reason",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "ReasonWlFlagQueryParameter": {
        "description": "Set the reason for watchlisting.\nValid values are:\n - \"WAS_BLACKLISTED\"\n",
        "name": "reason",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "RequestIDPathParameter": {
        "description": "This will be the same RequestId that was sent in the 202 acceptance response.\n",
        "name": "requestId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "format": "string"
        }
      },
      "ResultLevelPathParameter": {
        "description": "How much detail we return. \n\nAcceptable values are:\n  * simple - Only available with \"profile\" check type. Returns just an EntityProfileResultObject (which is also included for \"profile\" checks at the other result levels), and a CheckEntityCheckResultObjectEntityResult with just the entity details but no separate results.\n  * summary\n  * full - You need to have your account configured for this.\n",
        "name": "resultLevel",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string",
          "enum": ["simple", "summary", "full"]
        }
      },
      "ResultLevelQueryParameter": {
        "description": "Depth to which we need to retrieve parent entities. Values could be \"FULL\" or an integer. This param is optional. Default depth is FULL.\n",
        "name": "resultLevel",
        "in": "query",
        "schema": {
          "type": "string"
        }
      },
      "ResultLimitQueryParameter": {
        "description": "Limit the number of search results returned. Results may also be capped by a hard limit applied by the search service.\n",
        "name": "resultLimit",
        "in": "query",
        "schema": {
          "type": "integer"
        }
      },
      "SearchTypeQueryParameter": {
        "description": "The type of search to score matches for.\n\nThis parameter should not be specified unless by specific arrangement with Frankie.\n\nIf the search type \"none\" is used, then no scoring will be applied and there will be no confidence level for the results.\n",
        "name": "searchType",
        "in": "query",
        "schema": {
          "type": "string",
          "default": "entity_search"
        }
      },
      "SetEntityStatusQueryParameter": {
        "description": "The status of an entity.\nValid values are:\n  - \"wait\": Waiting for new details from entity.\n  - \"fail\": Manually fail the onboarding process.\n  - \"pass\": Manually pass the entity. Only allowed if entity is already actually passed.\n  - \"refer\": Set the entity onboarding as needing attention.\n  - \"archived\": Hide entity from on onboarding.\n  - \"clear\": Remove any of the above manual states as well as any manual risk.\n  - \"inactive\": Hide entity and prevent any further operations on it. Cannot be cleared.\n",
        "name": "set",
        "in": "query",
        "schema": {
          "type": "string",
          "enum": [
            "wait",
            "fail",
            "pass",
            "refer",
            "archived",
            "clear",
            "inactive"
          ]
        }
      },
      "SetFlagQueryParameter": {
        "description": "Set the value of an entity flag.\n",
        "name": "set",
        "in": "query",
        "required": true,
        "schema": {
          "type": "boolean"
        }
      },
      "TimeoutParameter": {
        "description": "Timeout in seconds to poll for a result. Ignored if awaitResult parameter is not supplied. Defaults to 30 seconds if not supplied. Minimum of 1 second and maximum of 60 seconds is allowed.\n",
        "name": "timeout",
        "in": "query",
        "schema": {
          "type": "integer"
        }
      },
      "UndoQueryParameter": {
        "description": "Undo a prior operation.\n",
        "name": "undo",
        "in": "query",
        "schema": {
          "type": "boolean"
        }
      }
    },
    "responses": {
      "respOk200AcceptedOwnershipQuery": {
        "description": "This is what you will find in the payload of a retrieved response should the ownership query succeed, or you're querying the past checks for a given business.\n\nNOTE:\n  When requesting the initial report, you will only ever receive a 202 response.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/OrganisationCheckResponseObject"
            }
          }
        }
      },
      "respOk200EntityReport": {
        "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EntityReportResultObject"
            }
          }
        }
      },
      "respOk200ParentAssociations": {
        "description": "This is the payload for parent associations request. It contains all the parent associations for a given entity.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ParentAssociationsQueryResult"
            }
          }
        }
      },
      "respOk200RetrieveResponse": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/RetrievedResponseObject"
            }
          }
        }
      },
      "respOk200SuccessBusinessReportOrderListResponse": {
        "description": "List of documents available for order for this entity.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BusinessReportOrderListResponse"
            }
          }
        }
      },
      "respOk200SuccessBusinessReportOrderStatus": {
        "description": "Status for this business report order is available.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BusinessReportOrderStatusResponse"
            }
          }
        }
      },
      "respOk200SuccessBusinessReportsResponse": {
        "description": "The request was valid and was successfully processed. The report was run and the results have been attached.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BusinessReportResponseDetails"
            }
          }
        }
      },
      "respOk200SuccessBusinessSubscriptionResponse": {
        "description": "The request was valid and was successfully processed. The subscription status has been updated.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BusinessSubscriptionResponseObject"
            }
          }
        }
      },
      "respOk200SuccessCheckEntity": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/CheckEntityCheckResultObject"
            }
          }
        }
      },
      "respOk200SuccessDeleteStaticEntityAssociationResponse": {
        "description": "The request was valid and was successfully processed. The entity association has been deleted.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BasicStatusResultObject"
            }
          }
        }
      },
      "respOk200SuccessDocument": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the document object as it stands now. No docScan file data will be returned unless the /full variant is requested.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentResultObject"
            }
          }
        }
      },
      "respOk200SuccessDocumentChecks": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the results of all checks carried out upon this document.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentChecksResultObject"
            }
          }
        }
      },
      "respOk200SuccessDocumentCompare": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the results of the document comparison process.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentCompareResultObject"
            }
          }
        }
      },
      "respOk200SuccessDocumentDelete": {
        "description": "The request was valid and able to be processed in some fashion. Returns a simple status to indicate that the deletion has taken place.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BasicStatusResultObject"
            }
          }
        }
      },
      "respOk200SuccessDocumentScan": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the results of the document scanning process.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentScanResultObject"
            }
          }
        }
      },
      "respOk200SuccessDocumentSearch": {
        "description": "The request was valid and able to be processed in some fashion. Returns a list of potentially matching documents or document references, along with a confidence level in the match.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentSearchResultObject"
            }
          }
        }
      },
      "respOk200SuccessDocumentVerify": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the results of the document verification process.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentVerifyResultObject"
            }
          }
        }
      },
      "respOk200SuccessEntity": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EntityResultObject"
            }
          }
        }
      },
      "respOk200SuccessEntityDelete": {
        "description": "The request was valid and able to be processed in some fashion. Returns a simple status to indicate that the deletion has taken place.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BasicStatusResultObject"
            }
          }
        }
      },
      "respOk200SuccessEntityIDV": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.\n\nAlso returned is the applicantId and token to be in the IDV process.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EntityIDVResultObject"
            }
          }
        }
      },
      "respOk200SuccessEntityReport": {
        "description": "The request was valid and able to be processed in some fashion. Results may or may not be successful, but it was completed as far as practical with no actual errors. Returns the entity object as it stands now. No docScan file data from any attached ID documents will be returned unless the /full variant is requested.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EntityResultObject"
            }
          }
        }
      },
      "respOk200SuccessEntitySearch": {
        "description": "The request was valid and able to be processed in some fashion. Returns a list of potentially matching entity or entity references, along with a confidence level in the match.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EntitySearchResultObject"
            }
          }
        }
      },
      "respOk200SuccessInternationalBusinessProfileResponse": {
        "description": "The request was valid and was successfully processed. The search has been carried out and the results are attached.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/InternationalBusinessProfileResponse"
            }
          }
        }
      },
      "respOk200SuccessInternationalBusinessSearchResponse": {
        "description": "The request was valid and was successfully processed. The search has been carried out and the results are attached.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/InternationalBusinessSearchResponse"
            }
          }
        }
      },
      "respOk200SuccessStaticEntityAssociationResponse": {
        "description": "The request was valid and was successfully processed. The entity association has been updated.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/StaticEntityAssociationResponse"
            }
          }
        }
      },
      "respOk202AcceptedBusinessReportOrder": {
        "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AcceptedResultObject"
            }
          }
        }
      },
      "respOk202AcceptedBusinessReportsResponse": {
        "description": "The request was valid and can potentially be fullfilled. The Frankie service has now accepted responsibility for processing and will send you a notification when the reports are ready.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/BusinessReportResponseDetails"
            }
          }
        }
      },
      "respOk202AcceptedCheckOrganisation": {
        "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AcceptedEntityResultObject"
            }
          }
        }
      },
      "respOk202AcceptedDocument": {
        "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AcceptedDocumentResultObject"
            }
          }
        }
      },
      "respOk202AcceptedEntity": {
        "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AcceptedEntityResultObject"
            }
          }
        }
      },
      "respOk202AcceptedOwnershipQuery": {
        "description": "The request was valid and can potentially be fulfilled. The Frankie service has now accepted responsibility for processing and we will either push the results to you, or send you a notification, depending on the request and your configuration.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AcceptedEntityResultObject"
            }
          }
        }
      },
      "respSystem200OK": {
        "description": "The system is fine. No issues, and everyone gets a puppy. But only if a Customer ID is supplied, otherwise, no puppy for you. Also, try asking nicely.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/PuppyObject"
            }
          }
        }
      },
      "respSystem500NotGood": {
        "description": "The system is presently unavailable, or running in a severely degraded state. Check the error message for details",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ErrorObject"
            }
          }
        }
      }
    },
    "requestBodies": {
      "EntityObject": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EntityObject"
            }
          }
        },
        "description": "The organisation to be queried. An entity object that must have be an ORGANISATION type with at least one organisation number (ABN or ACN).\n",
        "required": true
      },
      "EntityCheckDetailsObject": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EntityCheckDetailsObject"
            }
          }
        },
        "description": "The entity and any associated / additional information to be checked",
        "required": true
      }
    },
    "securitySchemes": {
      "api_key": {
        "description": "API key issued by Frankie Financial. This will rotate regularly.",
        "type": "apiKey",
        "name": "api_key",
        "in": "header"
      }
    },
    "schemas": {
      "AMLResultSet": {
        "description": "Wrapper object to contain a single set of AML check results.",
        "type": "object",
        "properties": {
          "checkResultsListMedia": {
            "description": "Collection of check results for the entity being found in any adverse media\n\nAn array sorted by type, then reverse chronological order of some/all background checks done on this entity. Older checks may have been previously done by you or another institution, and if so, these will be listed and appropriately anonymised/obfuscated.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/backgroundCheckResultObjectContainer"
            },
            "x-omitempty": true
          },
          "checkResultsListPEP": {
            "description": "Collection of check results for the entity being a Politically Exposed Person\n\nAn array sorted by type, then reverse chronological order of some/all background checks done on this entity. Older checks may have been previously done by you or another institution, and if so, these will be listed and appropriately anonymised/obfuscated.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/backgroundCheckResultObjectContainer"
            },
            "x-omitempty": true
          },
          "checkResultsListSanctions": {
            "description": "Collection of check results for the entity being on a sanctions list\n\nAn array sorted by type, then reverse chronological order of some/all background checks done on this entity. Older checks may have been previously done by you or another institution, and if so, these will be listed and appropriately anonymised/obfuscated.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/backgroundCheckResultObjectContainer"
            },
            "x-omitempty": true
          },
          "checkResultsListWatchlists": {
            "description": "Collection of check results for the entity being on a watchlist\n\nAn array sorted by type, then reverse chronological order of some/all background checks done on this entity. Older checks may have been previously done by you or another institution, and if so, these will be listed and appropriately anonymised/obfuscated.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/backgroundCheckResultObjectContainer"
            },
            "x-omitempty": true
          },
          "groupDetails": {
            "$ref": "#/components/schemas/backgroundCheckResultObjectContainer"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AMLResultSet"
        }
      },
      "AMLScreeningResult": {
        "description": "The results of any AML/Adverse media screening undertaken\n",
        "type": "object",
        "properties": {
          "check_result": {
            "description": "The overall result",
            "type": "string",
            "enum": ["NOT_SCREENED", "CLEAR", "POSSIBLE_HIT"]
          },
          "media_hit_count": {
            "description": "The number of adverse media hits.",
            "type": "integer",
            "example": 0
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AMLScreeningResult"
        }
      },
      "Abr": {
        "type": "object",
        "properties": {
          "abn": {
            "type": "string"
          },
          "acn": {
            "type": "string"
          },
          "addresses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MainBusinessPhysicalAddress"
            }
          },
          "businessNames": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BusinessName"
            }
          },
          "charityEndorsements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CharityEndorsement"
            }
          },
          "charityTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CharityType"
            }
          },
          "description": {
            "type": "string"
          },
          "dgrEndorsements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DgrEndorsement"
            }
          },
          "gst": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GoodsAndServicesTax"
            }
          },
          "historicalChanges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HistoricalChange"
            }
          },
          "lastUpdated": {
            "type": "string",
            "format": "date-time"
          },
          "name": {
            "type": "string"
          },
          "registeredDate": {
            "type": "string",
            "format": "date-time"
          },
          "status": {
            "type": "string"
          },
          "statusEffectiveFrom": {
            "type": "string"
          },
          "type": {
            "type": "string"
          },
          "typeCode": {
            "type": "string"
          },
          "updatedDate": {
            "type": "string",
            "format": "date-time"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "Abr"
        }
      },
      "AcceptedDocumentResultObject": {
        "description": "The following fields represent the data you need in order to retrieve the results of the requested function. See the details of the notification API for more.\n",
        "type": "object",
        "properties": {
          "checkId": {
            "description": "If you're calling a processing function of some kind, a check number will be issued. This field will only be present if the function you're calling would normally return a checkId (such as scan, verify, and compare).\n",
            "type": "string",
            "format": "uuid"
          },
          "documentId": {
            "description": "When an ID document is created/uploaded, it is assigned a documentId. You'll see this in a successful response or successfully accepted response. This can then be referenced in subsequent calls if you're uploading more/updated data.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "function": {
            "description": "Short description of the function called.\n",
            "type": "string"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        }
      },
      "AcceptedEntityResultObject": {
        "description": "The following fields represent the data you need in order to retrieve the results of the requested function. See the details of the notification API for more.\n",
        "type": "object",
        "properties": {
          "checkId": {
            "description": "If you're calling a processing function of some kind, a check number will be issued. This field will only be present if the function you're calling would normally return a checkId (such as scan, verify, and compare).\n",
            "type": "string",
            "format": "uuid"
          },
          "entityId": {
            "description": "When an entity is created/uploaded, or generated from a document scan, it is assigned an entityId. This can then be referenced in subsequent calls if you're uploading more/updated data.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "function": {
            "description": "Short description of the function called.\n",
            "type": "string"
          },
          "linkURL": {
            "description": "Optional link that can be returned - used by the Push To Mobile service to allow API users to manage the use of the onboarding link themselves.\n",
            "type": "string"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        }
      },
      "AcceptedResultObject": {
        "description": "The following fields represent the data you need in order to retrieve the results of the requested function.\n",
        "type": "object",
        "properties": {
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AcceptedResultObject"
        }
      },
      "ActivityDTO": {
        "type": "object",
        "properties": {
          "Code": {
            "type": "string"
          },
          "Description": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ActivityDTO"
        }
      },
      "ActivityDeclarationDTO": {
        "type": "object",
        "properties": {
          "Declaration": {
            "type": "string"
          },
          "DeclarationDescription": {
            "type": "string"
          },
          "Language": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ActivityDeclarationDTO"
        }
      },
      "AddressCheckResultObject": {
        "description": "This object holds the address that was checked and the results associated with said checks.\nYou can also leave the checkResult blank/nil if there are no results for that address if you wish. \nThis is useful for returning results on a freshly crerated entity where the API user would want to confirm that the data has indeed been stored, and be able to capture relevant addressIDs - perhaps to address issues as to why it wasn't checked.\n",
        "type": "object",
        "properties": {
          "address": {
            "$ref": "#/components/schemas/AddressObject"
          },
          "checkResult": {
            "$ref": "#/components/schemas/generalCheckResultArray"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AddressCheckResultObject"
        }
      },
      "AddressDTO": {
        "type": "object",
        "properties": {
          "AddressInOneLine": {
            "type": "string"
          },
          "AddressLine1": {
            "type": "string"
          },
          "AddressLine2": {
            "type": "string"
          },
          "AddressLine3": {
            "type": "string"
          },
          "AddressLine4": {
            "type": "string"
          },
          "AddressLine5": {
            "type": "string"
          },
          "CityTown": {
            "type": "string"
          },
          "ConcatenatedAddress": {
            "description": "This field is the concatenated version of the AddressLine1 - AddressLine5 fields. Contact our operations team to enable this field\n",
            "type": "string"
          },
          "Country": {
            "type": "string"
          },
          "Email": {
            "type": "string"
          },
          "FaxNumber": {
            "type": "string"
          },
          "Line": {
            "$ref": "#/components/schemas/ArrayOfAddressLineDTO"
          },
          "Postcode": {
            "type": "string"
          },
          "RegionState": {
            "type": "string"
          },
          "TelephoneNumber": {
            "type": "string"
          },
          "Type": {
            "type": "string"
          },
          "TypeCode": {
            "type": "string"
          },
          "WebsiteUrl": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AddressDTO"
        }
      },
      "AddressLineDTO": {
        "type": "object",
        "properties": {
          "Line": {
            "type": "string"
          },
          "Type": {
            "type": "string"
          },
          "TypeCode": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AddressLineDTO"
        }
      },
      "AddressObject": {
        "type": "object",
        "required": ["country"],
        "properties": {
          "addressId": {
            "description": "As addresses are added to an entity, they're assigned an id to assist with tracking. \n\nIf you're adjusting an address, you will need to include the addressId so as to be able to reference it correctly in the list.\n",
            "type": "string",
            "format": "uuid",
            "example": "86932629-bdb4-158f-e670-741e89ff78ba"
          },
          "addressType": {
            "$ref": "#/components/schemas/enumAddressType"
          },
          "buildingName": {
            "description": "The name of the building, apartment block, condo, etc",
            "type": "string",
            "example": "Highland Tower"
          },
          "careOf": {
            "description": "Individual or business name at this address if not the same as the name of the entity to which this address belongs.\n",
            "type": "string"
          },
          "country": {
            "description": "The ISO-3166-1 country. You must use the alpha3 country code (e.g. AUS, USA, IDR, KOR, etc) We'll convert as needed. \n\nSee: https://en.wikipedia.org/wiki/ISO_3166-1\n",
            "type": "string",
            "example": "AUS"
          },
          "endDate": {
            "description": "The date this address was no longer used (if available). Used mostly with business addresses.\n",
            "type": "string",
            "format": "date",
            "example": "0001-01-01"
          },
          "extraData": {
            "description": "Set of key-value pairs that provide arbitrary additional type-specific data. This data will typically not be visible in the Frankie Portal.\nIf updating an existing address, then existing values with the same name will be overwritten. New values will be added.\n\nSee here for more information about possible values you can use:\n  https://docs.frankieone.com/docs/key-value-pairs\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyValuePairObject"
            },
            "x-omitempty": true
          },
          "longForm": {
            "description": "In some cases, the address will need to be supplied in \"long form\", such as when it is determined from a document scan, or is un-parsable in some way.\nThe service will attempt to convert it to it's constituent parts where possible.\n\nWARNING: Use of longForm is not guaranteed to produce perfect results, due to the variety of potential formats. You've been warned. \nFailure to break down or disambiguate the address will result in an error.\n",
            "type": "string",
            "example": "42a Test Eagle Road, Testville, TST 123-TST, Testalia"
          },
          "postalCode": {
            "description": "The post code of the address.",
            "type": "string",
            "example": "3000"
          },
          "region": {
            "description": "The county, province, cantonment",
            "type": "string",
            "example": "MELBOURNE"
          },
          "startDate": {
            "description": "The date this address first because active. Used mostly with business addresses.\n",
            "type": "string",
            "format": "date",
            "example": "2023-03-10"
          },
          "state": {
            "description": "The state. Use local abbreviations, such as VIC(toria) or TX (Texas)",
            "type": "string",
            "example": "VIC"
          },
          "streetName": {
            "description": "The name of the street\n\nThis field can in fact be a bit flexible, potentially containing the streetNumber and streetType as well. Most services in use can work it out.\n\nIf this field has been auto-populated by Google (see writeup here:\n\nhttps://docs.frankieone.com/docs/working-with-addresses\nthen the bulk of the address will be in this field.\n\nIf you can avoid it though, please try and keep things separate.\n",
            "type": "string",
            "example": "9 ROYCE AVENUE"
          },
          "streetNumber": {
            "description": "The number on the street. Generally a number, but can also be alphanumeric (e.g. 3A)\n",
            "type": "string",
            "example": "FLAT 27"
          },
          "streetType": {
            "description": "The street \"type\" - e.g. Road, St, Ave, Circuit, etc",
            "type": "string",
            "example": "Road"
          },
          "suburb": {
            "description": "The suburb in the town/city. Only use this if you require a suburb AND a town/city, otherwise, just use the \"town\" parameter.",
            "type": "string",
            "example": "Testburb"
          },
          "town": {
            "description": "The town/village/suburb/city",
            "type": "string",
            "example": "MELBOURNE"
          },
          "unitNumber": {
            "description": "Unit/Apartment/Flat/Suite/etc number",
            "type": "string",
            "example": "FLAT 27"
          },
          "unstructuredLongForm": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AddressObject"
        }
      },
      "ArrayOfActivityDTO": {
        "type": "object",
        "properties": {
          "ActivityDTO": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActivityDTO"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfActivityDTO"
        }
      },
      "ArrayOfActivityDeclarationDTO": {
        "type": "object",
        "properties": {
          "ActivityDeclarationDTO": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ActivityDeclarationDTO"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfActivityDeclarationDTO"
        }
      },
      "ArrayOfAddressDTO": {
        "type": "object",
        "properties": {
          "Addresses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AddressDTO"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfAddressDTO"
        }
      },
      "ArrayOfAddressLineDTO": {
        "type": "object",
        "properties": {
          "AddressLineDTO": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AddressLineDTO"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfAddressLineDTO"
        }
      },
      "ArrayOfCapitalDTO": {
        "type": "object",
        "properties": {
          "CapitalDTO": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CapitalDTO"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfCapitalDTO"
        }
      },
      "ArrayOfCompanyDTO": {
        "type": "object",
        "properties": {
          "CompanyDTO": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CompanyDTO"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfCompanyDTO"
        }
      },
      "ArrayOfDirector": {
        "type": "object",
        "properties": {
          "Director": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Director"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfDirector"
        }
      },
      "ArrayOfDirectorship": {
        "type": "object",
        "properties": {
          "Directorship": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Directorship"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfDirectorship"
        }
      },
      "ArrayOfPSCDetails": {
        "type": "object",
        "properties": {
          "PSCDetails": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PSCDetails"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfPSCDetails"
        }
      },
      "ArrayOfShareholderDetails": {
        "type": "object",
        "properties": {
          "ShareholderDetails": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ShareholderDetails"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfShareholderDetails"
        }
      },
      "ArrayOfString": {
        "type": "object",
        "properties": {
          "AddressLine": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfString"
        }
      },
      "ArrayOfString1": {
        "type": "object",
        "properties": {
          "AddressLine": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfString1"
        }
      },
      "ArrayOfUSOfficerDTO": {
        "type": "object",
        "properties": {
          "USOfficerDTO": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/USOfficerDTO"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ArrayOfUSOfficerDTO"
        }
      },
      "AssociationObject": {
        "description": "Defines an association of an entity to it's parent\n",
        "type": "object",
        "properties": {
          "association": {
            "description": "The association if it's ubo, share-holder, officer etc\n",
            "type": "string"
          },
          "parentId": {
            "description": "parent entity ID",
            "type": "string",
            "format": "uuid"
          },
          "roleDescriptions": {
            "type": "array",
            "items": {
              "description": "roles",
              "type": "string"
            },
            "x-omitempty": true
          },
          "roles": {
            "type": "array",
            "items": {
              "description": "roles",
              "type": "string"
            },
            "x-omitempty": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AssociationObject"
        }
      },
      "AtbData": {
        "type": "object",
        "properties": {
          "accountAbnHistory": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "othersAbnHistory": {
            "$ref": "#/components/schemas/OthersAbnHistory"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AtbData"
        }
      },
      "AverageOverdue": {
        "type": "object",
        "properties": {
          "color": {
            "type": "string",
            "example": "#53ad58"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": "[\"6\",\"6\",\"9\",\"7\",\"7\",\"7\",\"7\",\"7\",\"7\",\"6\",\"6\",\"10\"]"
          },
          "name": {
            "type": "string",
            "example": "Average Days Overdue"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "AverageOverdue"
        }
      },
      "backgroundCheckResultObject": {
        "description": "Contains the details of a background check for a given entity. Background checks include Politically Exposed Person (PEP), sanctions lists, watchlists and adverse media.",
        "type": "object",
        "properties": {
          "backgroundCheckType": {
            "$ref": "#/components/schemas/enumBackgroundCheckType"
          },
          "checkDetails": {
            "description": "Any additional notes that may relate to the state. Free form notes that may contain JSON blobs needing further interpretation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyValuePairObject"
            },
            "x-omitempty": true
          },
          "checkFrequency": {
            "$ref": "#/components/schemas/enumBackgroundCheckFrequency"
          },
          "checkId": {
            "$ref": "#/components/schemas/CheckIDObject"
          },
          "checkPerformedBy": {
            "description": "Service provider that performed the check. Basically the name of the connector, without the leading con_\n",
            "type": "string",
            "example": "dvs"
          },
          "checkSource": {
            "description": "Code that can be used to determine the underlying nature or data source of the checks performed. This may or may not be known by the connector, or may be a provider specific type (e.g. type \"O\")\n",
            "type": "string",
            "example": "DVS"
          },
          "confidenceLevel": {
            "description": "Confidence in the current results on a scale of 0 (none) to 100 (as certain as possible). Whole integers only.",
            "type": "integer",
            "format": "int32",
            "maximum": 100,
            "minimum": 0,
            "example": 70
          },
          "currentState": {
            "$ref": "#/components/schemas/enumBackgroundCheckState"
          },
          "firstCheckDate": {
            "description": "The date and time the item was first checked.",
            "type": "string",
            "format": "date-time",
            "example": "2017-11-12T13:14:15Z+10:00"
          },
          "latestCheckDate": {
            "description": "The date and time the item was last checked to provide this result.",
            "type": "string",
            "format": "date-time",
            "example": "2018-11-12T13:14:15Z+10:00"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BackgroundCheckResultObject"
        }
      },
      "backgroundCheckResultObjectContainer": {
        "description": "Wraps up a BCRO with its internal ID.",
        "type": "object",
        "properties": {
          "bcro": {
            "$ref": "#/components/schemas/backgroundCheckResultObject"
          },
          "id": {
            "description": "Internal ID of this BCRO. Use this if you need to set the status.",
            "type": "string",
            "format": "uuid"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BackgroundCheckResultObjectContainer"
        }
      },
      "BasicStatusResultObject": {
        "type": "object",
        "required": ["requestId", "statusMsg"],
        "properties": {
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "statusMsg": {
            "description": "Simple message describing the final status of the process. Only to be used in success case responses. Otherwise, use the ErrorObject.\n",
            "type": "string",
            "example": "Thingy has been successfully processed."
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BasicStatusResultObject"
        }
      },
      "BeneficialOwnerObject": {
        "type": "object",
        "properties": {
          "addedBy": {
            "description": "If this owner was created from a request for a manual association, then this is the identity of the\nparty that requested that association. For requests via the Frankie portal this will default to the portal\nusername. Otherwise, if not given in the request, this will be your company name.\n",
            "type": "string"
          },
          "entityId": {
            "description": "The entityId of the owner.\n",
            "type": "string",
            "format": "uuid",
            "example": "3c7461f0-a8d1-5de5-d866-a19cbfd771ec"
          },
          "percentageHeld": {
            "$ref": "#/components/schemas/BeneficialOwnerObjectPercentageHeld"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BeneficialOwnerObject"
        }
      },
      "BeneficialOwnerObjectPercentageHeld": {
        "type": "object",
        "properties": {
          "beneficially": {
            "type": "number"
          },
          "isBeneficialNearZero": {
            "description": "Indicates if the beneficially held percentage is negligible.",
            "type": "boolean"
          },
          "isContainingJointOwnership": {
            "description": "Indicates if the percentage held contains a jointly held percentage.\n",
            "type": "boolean"
          },
          "isNonBeneficialNearZero": {
            "description": "Indicates if the non-beneficially held percentage is negligible.",
            "type": "boolean"
          },
          "isTotalNearZero": {
            "description": "Indicates if the total percentage is negligible.",
            "type": "boolean"
          },
          "jointly": {
            "type": "number"
          },
          "nonBeneficially": {
            "type": "number"
          },
          "total": {
            "type": "number"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BeneficialOwnerObjectPercentageHeld"
        }
      },
      "BlockingReasonCandidate": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "code": {
            "type": "string"
          },
          "countryIso": {
            "type": "string"
          },
          "registeredName": {
            "type": "string"
          },
          "registryDescription": {
            "type": "string"
          },
          "subdivision": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BlockingReasonCandidate"
        }
      },
      "BusinessDetails": {
        "description": "The details of the company being checked\n",
        "type": "object",
        "required": [
          "registered_name",
          "ABN",
          "ACN",
          "ARBN",
          "giin",
          "anzsic_code"
        ],
        "properties": {
          "ABN": {
            "type": "string"
          },
          "ACN": {
            "type": "string"
          },
          "ARBN": {
            "type": "string"
          },
          "anzsic_code": {
            "type": "string"
          },
          "asic_company_type": {
            "type": "string"
          },
          "business_names": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "date_registered_with_asic": {
            "type": "string",
            "format": "date"
          },
          "entity_id": {
            "description": "Frankie's unique identifier for the business.\n\nUses a non-versioned UUID format\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "giin": {
            "type": "string"
          },
          "place_of_business": {
            "$ref": "#/components/schemas/AddressObject"
          },
          "public_company": {
            "type": "boolean"
          },
          "registered_name": {
            "type": "string"
          },
          "registered_office": {
            "$ref": "#/components/schemas/AddressObject"
          },
          "regulatory_information": {
            "$ref": "#/components/schemas/RegulatoryInformation"
          },
          "state_registered_with_asic": {
            "type": "string"
          },
          "stock_exchange_data": {
            "$ref": "#/components/schemas/StockExchangeData"
          },
          "trading_names": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessDetails"
        }
      },
      "BusinessName": {
        "type": "object",
        "properties": {
          "effectiveFrom": {
            "type": "string",
            "format": "date-time"
          },
          "effectiveTo": {
            "type": "string",
            "format": "date-time"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessName"
        }
      },
      "BusinessReportDetailsObject": {
        "description": "The metadata details of the report generated .\n",
        "type": "object",
        "properties": {
          "providerReportId": {
            "description": "If the report provider generated an ID it goes here",
            "type": "string"
          },
          "reportDateTime": {
            "description": "The ISO UTC date and time the report was generated\n",
            "type": "string",
            "format": "date-time"
          },
          "reportId": {
            "description": "Unique Id used to order report.",
            "type": "string",
            "example": "7845e760-b297-b5a4-d518-2c63b7848719"
          },
          "reportName": {
            "description": "The name of the requested report",
            "type": "string",
            "example": "creditScore"
          },
          "reportProvider": {
            "description": "The name of the service provider that generated the report.\n",
            "type": "string",
            "example": "creditorwatch"
          },
          "reportRun": {
            "description": "Whether the report was successfully run or not\n",
            "type": "boolean"
          },
          "reportStatus": {
            "description": "Any details of what is happening with the report of not run.\n\nWill be one of:\n  - OK  (the report was run)\n  - LATER  (the report will be sent later as a response notification)\n  - An error message as to why the report did not work\n",
            "type": "string",
            "example": "OK"
          },
          "reportUrl": {
            "description": "Url to fetch report document.\n",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportDetailsObject"
        }
      },
      "BusinessReportFetchResponse": {
        "description": "The results of the requested reports.\n",
        "type": "object",
        "properties": {
          "checkId": {
            "description": "Unique Frankie identifier for the report operation.\n",
            "type": "string",
            "format": "uuid"
          },
          "entityId": {
            "description": "The ID of the entity this report is belongs to.\n",
            "type": "string",
            "format": "uuid"
          },
          "reports": {
            "description": "The collection of the fetched PDF report document(s) (currently just a single entry).\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IdentityDocumentObject"
            }
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportFetchResponse"
        }
      },
      "BusinessReportListDetail": {
        "description": "Details of available reports\n",
        "type": "object",
        "properties": {
          "availableFormats": {
            "description": "available formats",
            "type": "string",
            "example": "PDF"
          },
          "priceTierCode": {
            "$ref": "#/components/schemas/EnumPriceTierCode"
          },
          "provider": {
            "description": "The name of the service provider offering the report.",
            "type": "string",
            "example": "kyckr"
          },
          "reportCode": {
            "description": "product code with which to order the report.",
            "type": "string",
            "example": "ASICON_QVNJQ19Db21wYW55UHJvZmlsZUhpc3RvcmljYWxfRGF0YXN0cmVhbQ==_QVNJQ19DUEhfRFM=_NjAwMDk0OTYwX1ZPREFGT05FIFBUWSBMVEQ="
          },
          "reportTitle": {
            "description": "The title of the requested report",
            "type": "string",
            "example": "Current and Historical Company Information"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportListDetail"
        }
      },
      "BusinessReportListResponse": {
        "description": "The results of the available reports.\n",
        "type": "object",
        "properties": {
          "availableReports": {
            "description": "The collection of the available reports.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ReportDetail"
            }
          },
          "checkId": {
            "description": "Unique Frankie identifier for the report operation.\n",
            "type": "string",
            "format": "uuid"
          },
          "entityId": {
            "description": "The ID of the entity this report is belongs to.\n",
            "type": "string",
            "format": "uuid"
          },
          "providerCheckId": {
            "description": "Unique identifier provided by the service.\n",
            "type": "string"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportListResponse"
        }
      },
      "BusinessReportOrder": {
        "description": "Details of the organisation for which ownership should be queried. This should at least contain the ACN in the externalIds.\n",
        "type": "object",
        "required": ["reportType", "organisation"],
        "properties": {
          "generateReportDocument": {
            "description": "Should the report(s) also be generated as a document (pdf).",
            "type": "boolean"
          },
          "organisation": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "reportType": {
            "description": "Define the report you wish to run. These reports are different to the business details and UBO queries and are meant to provide deeper detail and background on a business or organisation.\nValid report types are:\n  - creditScore\n  - creditReport\n  - reportCode\n",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportOrder"
        }
      },
      "BusinessReportOrderListResponse": {
        "description": "List of reports available for order\n",
        "type": "object",
        "properties": {
          "entityId": {
            "description": "The ID of the entity the list of reports belongs to.\n",
            "type": "string",
            "format": "uuid"
          },
          "reports": {
            "description": "The collection of the available reports.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BusinessReportListDetail"
            }
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportOrderListResponse"
        }
      },
      "BusinessReportOrderStatus": {
        "description": "Details of the report order status\n",
        "type": "object",
        "properties": {
          "lastFetchRun": {
            "description": "time of last fetch run",
            "type": "string",
            "example": "0001-01-01 00:00:00 +0000 UTC"
          },
          "nextFetchRun": {
            "description": "time of next fetch run",
            "type": "string",
            "example": "0001-01-01 00:00:00 +0000 UTC"
          },
          "reportCode": {
            "description": "product code with which to order the report",
            "type": "string",
            "example": "ASICON_QVNJQ19Db21wYW55UHJvZmlsZUhpc3RvcmljYWxfRGF0YXN0cmVhbQ==_QVNJQ19DUEhfRFM=_NjAwMDk0OTYwX1ZPREFGT05FIFBUWSBMVEQ="
          },
          "reportStatus": {
            "description": "curent status of the report order. eg: Request received, Waiting on Provider",
            "type": "string",
            "example": "Waiting on Provider"
          },
          "reportTitle": {
            "description": "title of the final report (optional)",
            "type": "string",
            "example": "provider-reportCode"
          },
          "reportUrl": {
            "description": "url of the final report (optional)",
            "type": "string",
            "example": "https://api.frankie.one:433/compliance/v1.2/document/7d365381-bc12-89da-3681-dafc72112dgt/full?scanDocId=7d365381-bc12-89da-3681-dafc7211sfgh"
          },
          "requestId": {
            "description": "request Id",
            "type": "string",
            "example": "01G12MZZXKCXN8G6EWK1D4RGA8"
          },
          "requestedDate": {
            "description": "date when order was requested",
            "type": "string",
            "example": "0001-01-01 00:00:00 +0000 UTC"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportOrderStatus"
        }
      },
      "BusinessReportOrderStatusResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BusinessReportOrderStatus"
          },
          {
            "type": "object",
            "properties": {
              "documentOrders": {
                "$ref": "#/components/schemas/BusinessReportOrderStatus"
              }
            }
          }
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportOrderStatusResponse"
        }
      },
      "BusinessReportResponseDetails": {
        "description": "Results of the entity create or update along with the results of the requested reports.\n",
        "type": "object",
        "properties": {
          "checkId": {
            "description": "Unique Frankie identifier for the report operation.\n",
            "type": "string",
            "format": "uuid",
            "example": "88c0eb03-6f83-c1b9-cb09-628b8d70e782"
          },
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "providerCheckId": {
            "description": "Unique identifier provided by the service.\n",
            "type": "string"
          },
          "reports": {
            "description": "The collection of requested business reports.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BusinessReportResponseObject"
            }
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportResponseDetails"
        }
      },
      "BusinessReportResponseObject": {
        "description": "Container to hold the details of a report response\n\nThe actual report object will depend on the requested report.\n",
        "type": "object",
        "properties": {
          "checkId": {
            "type": "string",
            "format": "uuid"
          },
          "details": {
            "$ref": "#/components/schemas/BusinessReportDetailsObject"
          },
          "report": {
            "description": "The requested report object.\n\nThis will be one of:\n  - ReportCreditScore\n  - ReportCreditReport\n  - ReportPaymentPredictor\n",
            "type": "object",
            "x-omitempty": true
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportResponseObject"
        }
      },
      "BusinessReportResultObject": {
        "description": "The positive result of a report generation request if any.\n",
        "type": "object",
        "properties": {
          "documentId": {
            "type": "string",
            "format": "uuid"
          },
          "location": {
            "type": "string",
            "format": "uri"
          },
          "scanDocId": {
            "type": "string",
            "format": "uuid"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportResultObject"
        }
      },
      "BusinessSubscriptionResponseObject": {
        "description": "The positive result of a business ownership subcription request.\n",
        "type": "object",
        "properties": {
          "currentlySubscribed": {
            "description": "Is the ownership subscription currently active\n",
            "type": "boolean",
            "x-omitempty": false
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessSubscriptionResponseObject"
        }
      },
      "CapitalDTO": {
        "type": "object",
        "properties": {
          "Ammount": {
            "type": "string"
          },
          "Currency": {
            "type": "string"
          },
          "Type": {
            "type": "string"
          },
          "TypeCode": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CapitalDTO"
        }
      },
      "CapitalReserves": {
        "type": "object",
        "properties": {
          "capitalreserves": {
            "type": "string"
          },
          "networth": {
            "type": "string"
          },
          "paidupequity": {
            "type": "string"
          },
          "profitlossreserve": {
            "type": "string"
          },
          "reserves": {
            "type": "string"
          },
          "revalutationreserve": {
            "type": "string"
          },
          "shareholderfunds": {
            "type": "string"
          },
          "sundryreserves": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CapitalReserves"
        }
      },
      "CaseEntityProfileResultObject": {
        "$ref": "#/components/schemas/EntityProfileResultObject"
      },
      "CaseProcessResultObject": {
        "$ref": "#/components/schemas/ProcessResultObject"
      },
      "CaseRecord": {
        "description": "Details of a case.\n",
        "type": "object",
        "properties": {
          "alertList": {
            "description": "Comma-separated list of alerts associated with this monitoring alert.\n\nList of possible alerts supported:\n\n* PEP\n* SANCTION\n* WATCHLIST\n* MEDIA\n* DEATH\n* CRIME\n* BLACKLIST\n* IDTHEFT\n",
            "type": "string"
          },
          "assignee": {
            "description": "Portal user responsible for this case.",
            "type": "string"
          },
          "checkRisk": {
            "$ref": "#/components/schemas/ProcessResultObject"
          },
          "checkSummary": {
            "$ref": "#/components/schemas/ProcessResultObject"
          },
          "confidenceLevel": {
            "description": "Confidence in the result on a scale of 0 (no match) to 100 (strong/identical match). Whole integers only.\n",
            "type": "integer",
            "format": "int32",
            "maximum": 100,
            "minimum": 0
          },
          "createdRequestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "createdTimestamp": {
            "description": "The date and time the entity was created.",
            "type": "string",
            "format": "date-time",
            "x-go-custom-tag": "gorm:\"type:timestamp with time zone\""
          },
          "customerReference": {
            "type": "string"
          },
          "deletedRequestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "deletedTimestamp": {
            "description": "The date and time the entity was deleted.",
            "type": "string",
            "format": "date-time",
            "x-go-custom-tag": "gorm:\"type:timestamp with time zone\""
          },
          "entityFlags": {
            "$ref": "#/components/schemas/EFOArray"
          },
          "entityId": {
            "description": "Unique entity identifier.",
            "type": "string",
            "format": "uuid",
            "x-go-custom-tag": "gorm:\"primaryKey;type:uuid\"",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "entityName": {
            "description": "Name of the entity.",
            "type": "string"
          },
          "entityProfile": {
            "type": "string"
          },
          "entityProfileResult": {
            "$ref": "#/components/schemas/EntityProfileResultObject"
          },
          "entityType": {
            "$ref": "#/components/schemas/enumEntityType"
          },
          "extraData": {
            "$ref": "#/components/schemas/KVPOArray"
          },
          "issueList": {
            "$ref": "#/components/schemas/IssueListImpl"
          },
          "orgTypeCode": {
            "type": "string"
          },
          "orgTypeDescription": {
            "type": "string"
          },
          "profilePolicy": {
            "type": "string"
          },
          "riskLevel": {
            "description": "Only supplied in a summary result. Used to indicate the ovall risk score for the entity at this point in time.\n",
            "type": "integer",
            "maximum": 100,
            "minimum": 0,
            "x-go-custom-tag": "gorm:\"type:integer\""
          },
          "transactionParentRequestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "transactionRequestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "transactionStatus": {
            "$ref": "#/components/schemas/enumTransactionStatusKYC"
          },
          "transactionTimestamp": {
            "description": "The date and time of the latest transaction.",
            "type": "string",
            "format": "date-time",
            "x-go-custom-tag": "gorm:\"type:timestamp with time zone\""
          },
          "transactionUsername": {
            "description": "Portal user responsible for this check.",
            "type": "string"
          },
          "updatedRequestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "updatedTimestamp": {
            "description": "The date and time the entity was updated.",
            "type": "string",
            "format": "date-time",
            "x-go-custom-tag": "gorm:\"type:timestamp with time zone\""
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CaseRecord"
        }
      },
      "CaseResultsUpdateObject": {
        "description": "Contains the list of result IDs within an AML case that we need to update, and the new state we need to update to.\n",
        "type": "object",
        "properties": {
          "newStatus": {
            "$ref": "#/components/schemas/enumCheckResultManualStatus"
          },
          "resultIDList": {
            "description": "A list of resultIDs that map into a given AML case.\n\nA resultID generally represents a person who turned up in the AML case result set.\n",
            "type": "array",
            "items": {
              "description": "Single resultId",
              "type": "string"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CaseResultsUpdateObject"
        }
      },
      "CharityEndorsement": {
        "type": "object",
        "properties": {
          "effectiveFrom": {
            "type": "string",
            "format": "date-time"
          },
          "effectiveTo": {
            "type": "string",
            "format": "date-time"
          },
          "type": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CharityEndorsement"
        }
      },
      "CharityType": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "effectiveFrom": {
            "type": "string",
            "format": "date-time"
          },
          "effectiveTo": {
            "type": "string",
            "format": "date-time"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CharityType"
        }
      },
      "CheckEntityCheckResultObject": {
        "description": "Describes all of the checks that were carried out against an entity as part of our cascading check process. Because there are a number of steps involved in checking an entity, (including the use of past checks done by you or others), there is an overall summary check result that will tell you the final disposition of the the check you requested.\n\nSo if you requested a 2+2+governmentID+pep/sanctions/etc (i.e. everything) then there would have been several checks done in order to meet this requirement. Some may have even failed, but eventually we got there. The summary gives the final assessment, based on all available data.\n\nDetailed writeups on how this all works can be found here:\n  https://docs.frankieone.com/docs/understanding-check-results\n",
        "type": "object",
        "properties": {
          "blacklistCheckResults": {
            "description": "Collection of check results for the entity having been previously blacklisted.\n\nAn array of matched blacklisted entities sorted by match confidence level (highest first).\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProcessResultObject"
            },
            "x-omitempty": true
          },
          "checkResultsListSummaries": {
            "description": "Contains a list of all checkSummary records (one for each check)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProcessResultObject"
            },
            "x-omitempty": true
          },
          "checkRisk": {
            "$ref": "#/components/schemas/ProcessResultObject"
          },
          "checkSummary": {
            "$ref": "#/components/schemas/ProcessResultObject"
          },
          "duplicateCheckResults": {
            "description": "Collection of check results for the entity having previously been checked.\n\nAn array of matched checked entities sorted by match confidence level (highest first).\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProcessResultObject"
            },
            "x-omitempty": true
          },
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "entityProfileResult": {
            "$ref": "#/components/schemas/EntityProfileResultObject"
          },
          "entityResult": {
            "$ref": "#/components/schemas/CheckEntityCheckResultObjectEntityResult"
          },
          "fraudCheckResults": {
            "$ref": "#/components/schemas/FraudCheckResultObject"
          },
          "manualCheckResults": {
            "description": "Collection of check results for the manual KYC.\n\nAn array of one entry with the manual check result.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProcessResultObject"
            },
            "x-omitempty": true
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "sharedBlocklistCheckResults": {
            "description": "Collection of check results for the entity having been previously blacklisted in shared blocklist.\n\nAn array of matched blacklisted entities sorted by match confidence level (highest first).\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProcessResultObject"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CheckEntityCheckResultObject"
        }
      },
      "CheckEntityCheckResultObjectEntityResult": {
        "description": "This will hold all of the check results that were performed against the\n",
        "type": "object",
        "properties": {
          "addressesCheck": {
            "description": "Collection of address objects.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AddressCheckResultObject"
            },
            "x-omitempty": true
          },
          "adverseMediaCheck": {
            "description": "!!!!! DEPRECATED !!!!!\nPlease use the multi-result AMLResultSets structure instead.\n\nNote: This single check result structure will be retired in v2.0\n!!!!! DEPRECATED !!!!!\n\nCollection of check results for the entity being found in any adverse media\n\nAn array sorted by type, then reverse chronological order of some/all background checks done on this entity. Older checks may have been previously done by you or another institution, and if so, these will be listed and appropriately anonymised/obfuscated.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/backgroundCheckResultObject"
            },
            "x-omitempty": true
          },
          "amlResultSets": {
            "description": "An array of Collections of PEP/Sanctions/WL/Media objects, as AML providers can return multiple results\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AMLResultSet"
            },
            "x-omitempty": true
          },
          "dateOfBirthCheck": {
            "$ref": "#/components/schemas/DOBCheckResultObject"
          },
          "entityId": {
            "description": "Unique ID for the entity.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "genderCheck": {
            "$ref": "#/components/schemas/GenderCheckResultObject"
          },
          "identityDocsCheck": {
            "description": "Collection of identity documents (photos, scans, selfies, etc), and their check results",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IdentityDocumentCheckResultObject"
            },
            "x-omitempty": true
          },
          "nameCheck": {
            "$ref": "#/components/schemas/PersonalNameCheckResultObject"
          },
          "pepCheck": {
            "description": "!!!!! DEPRECATED !!!!!\nPlease use the multi-result AMLResultSets structure instead.\n\nNote: This single check result structure will be retired in v2.0\n!!!!! DEPRECATED !!!!!\n\nCollection of check results for the entity being a Politically Exposed Person\n\nAn array sorted by type, then reverse chronological order of some/all background checks done on this entity. Older checks may have been previously done by you or another institution, and if so, these will be listed and appropriately anonymised/obfuscated.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/backgroundCheckResultObject"
            },
            "x-omitempty": true
          },
          "sanctionsCheck": {
            "description": "!!!!! DEPRECATED !!!!!\nPlease use the multi-result AMLResultSets structure instead.\n\nNote: This single check result structure will be retired in v2.0\n!!!!! DEPRECATED !!!!!\n\nCollection of check results for the entity being on a sanctions list\n\nAn array sorted by type, then reverse chronological order of some/all background checks done on this entity. Older checks may have been previously done by you or another institution, and if so, these will be listed and appropriately anonymised/obfuscated.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/backgroundCheckResultObject"
            },
            "x-omitempty": true
          },
          "watchlistCheck": {
            "description": "!!!!! DEPRECATED !!!!!\nPlease use the multi-result AMLResultSets structure instead.\n\nNote: This single check result structure will be retired in v2.0\n!!!!! DEPRECATED !!!!!\n\nCollection of check results for the entity being on a watchlist\n\nAn array sorted by type, then reverse chronological order of some/all background checks done on this entity. Older checks may have been previously done by you or another institution, and if so, these will be listed and appropriately anonymised/obfuscated.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/backgroundCheckResultObject"
            },
            "x-omitempty": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CheckEntityCheckResultObjectEntityResult"
        }
      },
      "CheckIDObject": {
        "description": "Unique identifier for every check/comparison/verification. Make sure you reference this ID whenever updating check details. This ID will also be used when pushing check results back to you.",
        "type": "string",
        "format": "uuid",
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CheckIDObject"
        },
        "example": "54a1116d-68ae-4d7d-9a53-505184a9a860"
      },
      "CheckResultUpdateObject": {
        "description": "Details of the status changes to be made to a check result.\n",
        "type": "object",
        "required": ["comment"],
        "properties": {
          "checkClassIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "comment": {
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/enumCheckResultManualStatus"
          }
        }
      },
      "CodeDescription": {
        "description": "A common pairing of a short code and a long description.",
        "type": "object",
        "properties": {
          "code": {
            "type": "string"
          },
          "description": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CodeDescription"
        }
      },
      "CompanyDTO": {
        "type": "object",
        "properties": {
          "Addresses": {
            "$ref": "#/components/schemas/ArrayOfAddressDTO"
          },
          "Aliases": {
            "$ref": "#/components/schemas/ArrayOfString"
          },
          "AliasesList": {
            "$ref": "#/components/schemas/ListOfString"
          },
          "Code": {
            "type": "string"
          },
          "CompanyID": {
            "type": "string"
          },
          "CompanyNameInEnglish": {
            "type": "string"
          },
          "Date": {
            "type": "string"
          },
          "Function": {
            "type": "string"
          },
          "LegalForm": {
            "type": "string"
          },
          "LegalStatus": {
            "type": "string"
          },
          "MoreKey": {
            "type": "string"
          },
          "Name": {
            "type": "string"
          },
          "Official": {
            "type": "boolean"
          },
          "RegistrationAuthority": {
            "type": "string"
          },
          "RegistrationAuthorityCode": {
            "type": "string"
          },
          "Source": {
            "type": "string"
          },
          "VirtualID": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CompanyDTO"
        }
      },
      "CompanyProfileDTO": {
        "type": "object",
        "properties": {
          "Activity": {
            "$ref": "#/components/schemas/ArrayOfActivityDTO"
          },
          "ActivityDeclaration": {
            "$ref": "#/components/schemas/ArrayOfActivityDeclarationDTO"
          },
          "Addresses": {
            "$ref": "#/components/schemas/ArrayOfAddressDTO"
          },
          "AgentAddress": {
            "type": "string"
          },
          "AgentName": {
            "type": "string"
          },
          "Aliases": {
            "$ref": "#/components/schemas/ArrayOfString"
          },
          "AliasesList": {
            "$ref": "#/components/schemas/ListOfString"
          },
          "AppointmentDateOfOfficial": {
            "type": "string"
          },
          "Capital": {
            "$ref": "#/components/schemas/ArrayOfCapitalDTO"
          },
          "Code": {
            "type": "string"
          },
          "CompanyNameInEnglish": {
            "type": "string"
          },
          "Date": {
            "type": "string"
          },
          "Email": {
            "type": "string"
          },
          "FaxNumber": {
            "type": "string"
          },
          "FiscalCode": {
            "type": "string"
          },
          "FoundationDate": {
            "type": "string"
          },
          "Functions": {
            "$ref": "#/components/schemas/ArrayOfString"
          },
          "FunctionsList": {
            "$ref": "#/components/schemas/ListOfString"
          },
          "Headquarters": {
            "type": "string"
          },
          "KeyFigures": {
            "$ref": "#/components/schemas/ArrayOfString"
          },
          "KeyFiguresList": {
            "$ref": "#/components/schemas/ListOfString"
          },
          "LastAnnualAccountDate": {
            "type": "string"
          },
          "LegalForm": {
            "type": "string"
          },
          "LegalFormDeclaration": {
            "type": "string"
          },
          "LegalFormDetails": {
            "$ref": "#/components/schemas/LegalFormDTO"
          },
          "LegalStatus": {
            "type": "string"
          },
          "MailingAddress": {
            "type": "string"
          },
          "Name": {
            "type": "string"
          },
          "NormalisedLegalForm": {
            "description": "Contact our operations team to enable this normalisation field\n",
            "type": "string",
            "example": "PUBLIC COMPANY"
          },
          "NormalisedLegalStatus": {
            "type": "string"
          },
          "NormalisedRegistrationDate": {
            "description": "Contact our operations team to enable this normalisation field\n",
            "type": "string",
            "example": "2023-04-23"
          },
          "Official": {
            "type": "boolean"
          },
          "RegistrationAuthority": {
            "type": "string"
          },
          "RegistrationAuthorityCode": {
            "type": "string"
          },
          "RegistrationDate": {
            "type": "string"
          },
          "RegistrationNumber": {
            "type": "string"
          },
          "SigningDeclaration": {
            "type": "string"
          },
          "SigningDeclarationDescription": {
            "type": "string"
          },
          "SigningLanguage": {
            "type": "string"
          },
          "Source": {
            "type": "string"
          },
          "StateOfIncorporation": {
            "type": "string"
          },
          "TelephoneNumber": {
            "type": "string"
          },
          "VatNumber": {
            "type": "string"
          },
          "VirtualId": {
            "type": "string"
          },
          "WebsiteURL": {
            "type": "string"
          },
          "directorAndShareDetails": {
            "$ref": "#/components/schemas/DirectorAndShareDetails"
          },
          "officers": {
            "$ref": "#/components/schemas/ArrayOfUSOfficerDTO"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CompanyProfileDTO"
        }
      },
      "ComparisonSet": {
        "description": "This is the document that we want to compare to the original toDocument.\n\nIn the case of a selfie-check against a drivers licence:\n\n  * compareDocument will be the the selfie\n  * toDocument will be the drivers licence photo\n",
        "type": "object",
        "properties": {
          "compareDocument": {
            "$ref": "#/components/schemas/IdentityDocumentObject"
          },
          "toDocument": {
            "$ref": "#/components/schemas/IdentityDocumentObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ComparisonSet"
        }
      },
      "CourtDetailsObject": {
        "description": "Officer court details as returned from an ASIC report.",
        "type": "object",
        "properties": {
          "applicationNumber": {
            "type": "string"
          },
          "applicationYear": {
            "type": "integer",
            "maximum": 2999,
            "minimum": 1000
          },
          "country": {
            "type": "string"
          },
          "state": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/CodeDescription"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CourtDetailsObject"
        }
      },
      "CourtJudgement": {
        "type": "object",
        "properties": {
          "action": {
            "description": "The name of the court judgement that was handed down",
            "type": "string",
            "title": "Court Action"
          },
          "actionDate": {
            "description": "The date of the court ruling",
            "type": "string",
            "format": "date-time",
            "title": "Action Date"
          },
          "createdDate": {
            "description": "The date the court judgement was received and published",
            "type": "string",
            "format": "date-time",
            "title": "Created Date"
          },
          "judgementAmount": {
            "description": "The amount the defendant was ordered by the court to pay to the\nplaintiff",
            "type": "number",
            "format": "float",
            "title": "Judgement Amount"
          },
          "location": {
            "description": "The location of the court judgment",
            "type": "string",
            "title": "Location"
          },
          "natureOfClaim": {
            "description": "Nature of the claim",
            "type": "string",
            "title": "Nature of Claim"
          },
          "natureOfClaimDesc": {
            "description": "Additional information regarding the nature of the claim",
            "type": "string",
            "title": "Nature of Claim Description"
          },
          "plaintiff": {
            "description": "The person or company that is taking the defendant to court",
            "type": "string",
            "title": "The Plaintiff Name"
          },
          "proceedingNumber": {
            "description": "Court judgement referencing identifier",
            "type": "string",
            "title": "Court Proceeding Number"
          },
          "state": {
            "description": "The state jurisdiction of the court judgement",
            "type": "string",
            "title": "State"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CourtJudgement"
        }
      },
      "CreditScoreHistory": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "format": "date-time"
          },
          "score": {
            "type": "integer",
            "example": 565
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CreditScoreHistory"
        }
      },
      "CreditScoreObject": {
        "type": "object",
        "properties": {
          "creditScoreHistory": {
            "description": "Shows the credit score for every month over the last year for this business",
            "type": "array",
            "title": "Credit Score History",
            "items": {
              "$ref": "#/components/schemas/CreditScoreHistory"
            }
          },
          "currentCreditScore": {
            "description": "The score ultimately ranks entities based on their riskiness and is designed to assist you in making more informed and consistent credit decisions.  The score is based between 0 and 850 index points with a higher score considered lower risk while lower scores are deemed to be riskier entities. It should be used in partnership with your internal credit procedures and policies.\nPlease note that the score and recommendation should be used in partnership with your company's internal credit procedures and policies. The score should not be used as the sole reason in making a decision about the entity.\n\n0 = Critical (ACN deregistered or ABN cancelled)\n\n1 - 125 = Entity has a critical status and significant adverse information present. Trading eligibility must be considered.)\n\n126 - 250 = Very High (Entity has a critical status and significant adverse information present. Trading eligibility must be considered)\n\n251 - 450 = High (Entity has a below average creditworthiness score and some adverse information may be present. Trade with caution, monitor closely and consider your payment terms)",
            "type": "integer",
            "title": "The Credit Score is a statistically based score indicating an entity's credit worthiness.",
            "example": 565
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "CreditScoreObject"
        }
      },
      "DOBCheckResultObject": {
        "type": "object",
        "properties": {
          "checkResult": {
            "$ref": "#/components/schemas/generalCheckResultArray"
          },
          "dob": {
            "$ref": "#/components/schemas/DOBObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DOBCheckResultObject"
        }
      },
      "DOBObject": {
        "type": "object",
        "properties": {
          "country": {
            "description": "ISO-3166-1 code for the country of birth. You must use the alpha3 country code (e.g. AUS, USA, IDR, KOR, etc) We'll convert as needed.\n\nSee https://en.wikipedia.org/wiki/ISO_3166-1\n",
            "type": "string",
            "example": "AUS"
          },
          "dateOfBirth": {
            "description": "Date of Birth in YYYY-MM-DD format",
            "type": "string",
            "format": "date",
            "example": "1978-11-12"
          },
          "locality": {
            "description": "Place of birth other than country If locality is given, then country must also be provided.\n",
            "type": "string",
            "example": "Brisbane"
          },
          "unstructuredDateOfBirth": {
            "type": "string"
          },
          "yearOfBirth": {
            "description": "Year of birth or \"unknown\". This will be autoextracted if dateOfBirth is supplied.",
            "type": "string",
            "example": "1978"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DOBObject"
        }
      },
      "DeviceCheckDetailsObject": {
        "description": "Contains any/all details we want to pass on to the device checking service as part of an activity / transaction. A transaction isn't just a payment, but can represent a number of different interaction types. See below for more.\n\nNOTE: If you're sending this data, then your recipe or requested checkTypes *MUST* include a \"device\" checkType. Otherwise this data will be ignored and dropped.\n",
        "type": "object",
        "properties": {
          "activityType": {
            "description": "The type of activity we're checking. Choices are:\n\n- SIGNUP: Used when an entity is signing up to your service\n- LOGIN: Used when an already registered entity is logging in to your service\n- PAYMENT: Used when you wish to check that all is well for a payment\n- CONFIRMATION: User has confirmed an action and you wish to double check they're still legitimate\n\nYou can also supply vendor specific activityTypes if you know them. To do this, make the first character an underscore _. \nSo for example, to use BioCatch's LOGIN_3 type, you can send \"_LOGIN_3\" as a value. Note, if you do this, there is no error checking on the Frankie side, and thus if you supply an incorrect value, the call will fail.\n",
            "type": "string"
          },
          "additionalData": {
            "description": "Collection of additional data points you wish to add to the activity check. These are defined in conjunction with the Customer and the device checking service being used.\n\nStandard values are supplied upon request:\n\n| kvpKey | kvpType | kvpValue |\n| ------- | -------- | -------- |\n| detectedIp | general.string | The IP address you detect the transaction coming from |\n| accountId.src | id.external | Your account identifier. Can be a SHA hash or similar |\n| accountId.dst | id.external | Target/payee account identifier. Can be a SHA hash or similar |\n| entityId | id.external | Use this to override the Frankie entityID that would be used to identify |\n| amount | general.float | Amount involved in the transaction  |\n| platform  | general.string | One of APP, WEB, MOBILE_WEB. Assumes APP if not supplied |\n|   |   |\n\n\nLike the activityType, you can also specify vendor specific additional data parameters by adding a leading underscore \"_\" to the kvpKey. You can set the kvpType to one of the available types, or just use general.string (recommended)\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyValuePairObject"
            },
            "x-omitempty": true
          },
          "checkSessionKey": {
            "description": "the unique session based ID that will be checked against the service.",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DeviceCheckDetailsObject"
        }
      },
      "DeviceObject": {
        "type": "object",
        "properties": {
          "extraData": {
            "description": "Set of key-value pairs that provide device type-specific data. If updating an existing device, then existing values with the same name will be overwritten. New values will be added.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyValuePairObject"
            },
            "x-omitempty": true
          },
          "fingerprint": {
            "description": "Service specific fingerprint for the device, prefixed with the name of the service and a colon (':')\n",
            "type": "string",
            "example": "sardine:84a9a860-68ae-4d7d-9a53-54a1116d5051"
          }
        }
      },
      "DgrEndorsement": {
        "type": "object",
        "properties": {
          "endorsedFrom": {
            "type": "string",
            "format": "date-time"
          },
          "endorsedTo": {
            "type": "string",
            "format": "date-time"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DgrEndorsement"
        }
      },
      "Director": {
        "type": "object",
        "properties": {
          "address1": {
            "type": "string"
          },
          "address2": {
            "type": "string"
          },
          "address3": {
            "type": "string"
          },
          "address4": {
            "type": "string"
          },
          "address5": {
            "type": "string"
          },
          "address6": {
            "type": "string"
          },
          "birthdate": {
            "type": "string"
          },
          "directorNumber": {
            "type": "string"
          },
          "directorships": {
            "$ref": "#/components/schemas/ArrayOfDirectorship"
          },
          "name": {
            "type": "string"
          },
          "nationality": {
            "type": "string"
          },
          "postcode": {
            "type": "string"
          },
          "title": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "Director"
        }
      },
      "DirectorAndShareDetails": {
        "type": "object",
        "properties": {
          "PersonsOfSignificantControl": {
            "$ref": "#/components/schemas/ArrayOfPSCDetails"
          },
          "capitalReserves": {
            "$ref": "#/components/schemas/CapitalReserves"
          },
          "directors": {
            "$ref": "#/components/schemas/ArrayOfDirector"
          },
          "shareHolderSummary": {
            "$ref": "#/components/schemas/ShareholderSummary"
          },
          "shareHolders": {
            "$ref": "#/components/schemas/ArrayOfShareholderDetails"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DirectorAndShareDetails"
        }
      },
      "Directorship": {
        "type": "object",
        "properties": {
          "appointedDate": {
            "type": "string"
          },
          "companyName": {
            "type": "string"
          },
          "companyNumber": {
            "type": "string"
          },
          "companyStatus": {
            "type": "string"
          },
          "function": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "Directorship"
        }
      },
      "DirectorshipsObject": {
        "type": "object",
        "properties": {
          "companyName": {
            "type": "string"
          },
          "companyNumber": {
            "type": "string"
          },
          "companyStatus": {
            "type": "string"
          },
          "function": {
            "type": "string"
          },
          "nationality": {
            "type": "string"
          },
          "unstructuredAppointedDate": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DirectorshipsObject"
        }
      },
      "DocumentChecksResultObject": {
        "description": "Contains the results of a given document upload.",
        "type": "object",
        "required": ["requestId"],
        "properties": {
          "checkResults": {
            "$ref": "#/components/schemas/IdentityDocumentCheckResultObject"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        }
      },
      "DocumentCompareResultObject": {
        "description": "Contains the results of a given document upload.",
        "type": "object",
        "required": ["requestId", "documentComparisonResults"],
        "properties": {
          "documentComparisonResults": {
            "$ref": "#/components/schemas/DocumentComparisonResultObject"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DocumentCompareResultObject"
        }
      },
      "DocumentComparisonResultObject": {
        "description": "Contains the details of a comparison between two documents",
        "type": "object",
        "properties": {
          "compareDocumentId": {
            "description": "This is a direct copy from the compareDocument object passed in the request. You MUST supply this.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "processResult": {
            "$ref": "#/components/schemas/ProcessResultObject"
          },
          "toDocumentId": {
            "description": "This is a direct copy from the toDocument object passed in the request. You MUST supply this.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DocumentComparisonResultObject"
        }
      },
      "DocumentResultObject": {
        "description": "Contains the results of a given document upload.",
        "type": "object",
        "required": ["requestId", "document"],
        "properties": {
          "document": {
            "$ref": "#/components/schemas/IdentityDocumentObject"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        }
      },
      "DocumentScanResultObject": {
        "description": "The result of a scan will contain 4 parts\n\n* The requestid - that's always there, and is the same that was passed in in the header.\n\n* The results of the process and the meta data around it, including confidence levels, service used and the like\n\n* extractedDocument - this will be an updated version of the document object passed in for scanning with results of the scan inserted. You can subsequently update this data as needed (say after confirmation with the end-consumer) through the various update functions. \n\n  * Any additional data extracted from the service that does not fit into the standard identity document fields will be placed into the extraData KVPs.\n  \n* extractedEntity - the service will attempt to create the basics of an entity's name, address, DoB, gender from the data returned from the scan. \n  You can then use this entity data to create a new entity for a wider check if needed.\n  \n  * Note if you plan on doing this, make sure you include the extractedDocument reference in the \"new\" entity.\n  \n* EXTRA SPECIAL NOTE: If no useful data was returned in the scan, extractedDocument will be left unchanged, and extractedEntity will be left out\n",
        "type": "object",
        "required": ["requestId", "processResult"],
        "properties": {
          "extractedDocument": {
            "$ref": "#/components/schemas/IdentityDocumentObject"
          },
          "extractedEntity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "processResult": {
            "$ref": "#/components/schemas/ProcessResultObject"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DocumentScanResultObject"
        }
      },
      "DocumentSearchResultListItem": {
        "description": "Contains the individual search results for a document.",
        "type": "object",
        "properties": {
          "confidence": {
            "$ref": "#/components/schemas/SearchResultConfidenceObject"
          },
          "document": {
            "$ref": "#/components/schemas/IdentityDocumentObject"
          }
        }
      },
      "DocumentSearchResultObject": {
        "description": "Contains the results of a given document search.",
        "type": "object",
        "required": ["requestId"],
        "properties": {
          "documentSearchResults": {
            "description": "The list of (potentially) matching documents with confidence levels.\n\nIf you are the \"owner\" of the document - i.e. the same CustomerID and CustomerChildID (if relevant) - then the full details of the document will be returned, except for the contents of any attached scans.\nIf you are not the owner of the document, then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET /document/{documentId}/checks)\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentSearchResultListItem"
            },
            "x-omitempty": true
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        }
      },
      "DocumentVerificationResultObject": {
        "description": "Contains the details of a check on a given data point",
        "type": "object",
        "properties": {
          "documentId": {
            "description": "This is a direct copy from the document object passed in for verifcation.",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "processResult": {
            "$ref": "#/components/schemas/ProcessResultObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DocumentVerificationResultObject"
        }
      },
      "DocumentVerify": {
        "description": "This is the document we wish to verify in some way, along with an entity object that contains some/all of the details we wish to verify.\n\nFor example, if we're attempting to verify a drivers licence, we generally need to pass in a name, address, DoB, etc as well. the entity gives the structure to be able to do this. \n\nNote, only the document in the \"document\" parameter is to be processed. any additional documents found in the entity (there shouldn't be, but given the way this has been defined, there can be) will be ignored. Only the Name, Address, DoB and Gender fields will be potentially used during the verification process.\n\nThe EntityObject can take one of two forms.\n\n  - It can be a single entityId - in which case the details will be pulled from the database. If using an existing document, then the entity must also own the document or the request will fail.\n  - You can supply a \"single use\" entity with fields, etc. In this case the entity details will be used to verify the document, then will be discarded.\n  \nIf you wish to save the entity, use the /entity comments instead to create the entity and attach the document there.\n",
        "type": "object",
        "properties": {
          "document": {
            "$ref": "#/components/schemas/IdentityDocumentObject"
          },
          "entityData": {
            "$ref": "#/components/schemas/EntityObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DocumentVerify"
        }
      },
      "DocumentVerifyResultObject": {
        "description": "Contains the results of a given document upload.",
        "type": "object",
        "required": ["requestId"],
        "properties": {
          "documentVerificationResults": {
            "$ref": "#/components/schemas/DocumentVerificationResultObject"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "DocumentVerifyResultObject"
        }
      },
      "dummyA0111": {
        "description": "Details of the report to be ordered\n",
        "type": "object",
        "properties": {
          "provider": {
            "description": "The name of the service provider from which to order the report.",
            "type": "string",
            "example": "kyckr"
          },
          "reportCode": {
            "description": "product code with which to order the report. This should come from the reportCode returned in the BusinessReportCatalogue endpoint",
            "type": "string",
            "example": "ASICON_QVNJQ19Db21wYW55UHJvZmlsZUhpc3RvcmljYWxfRGF0YXN0cmVhbQ==_QVNJQ19DUEhfRFM=_NjAwMDk0OTYwX1ZPREFGT05FIFBUWSBMVEQ="
          },
          "reportFormat": {
            "description": "report format (optional). eg: html, pdf",
            "type": "string",
            "example": "PDF"
          }
        },
        "x-go-gen-location": "models",
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "BusinessReportOrder"
        }
      },
      "EFOArray": {
        "description": "Additional information flags with regards to this entity and for ongoing processing. This *is* the flag data from the entity.\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/EntityFlagObject"
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EFOArray"
        },
        "x-omitempty": true
      },
      "EntityCheckDetailsObject": {
        "description": "Contains all the details we'll check regarding an Entity. It is assumed that this will grow over time.\n\nCurrent supported check parameters:\n\n  - entity: The Entity we're checking. This must be supplied.\n",
        "type": "object",
        "required": ["entity"],
        "properties": {
          "deviceCheckDetails": {
            "$ref": "#/components/schemas/DeviceCheckDetailsObject"
          },
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityCheckDetailsObject"
        }
      },
      "EntityFlagObject": {
        "description": "Similar to a KVP, the flag has a key (the flag you're indicating) and an integer value.\n\nValues are tied to the specific flag (see table below). Generally they're true (1)/false(0) indicators.\n\n    | flag | values | Description |\n    | ------- | -------- | -------- |\n    | ongoing_pep | 0, 1, 2 | 0 = no, 1 = pep/sanctions, 2 = 1+media |\n    |  |  |  |\n",
        "type": "object",
        "properties": {
          "flag": {
            "description": "Name of the flag",
            "type": "string"
          },
          "value": {
            "description": "flag value.",
            "type": "integer",
            "x-omitempty": false
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityFlagObject"
        }
      },
      "EntityIDVDetailsObject": {
        "description": "Contains all the details we need to create/update an entity and generate an IDV token\n",
        "type": "object",
        "required": ["entity"],
        "properties": {
          "applicantId": {
            "description": "The applicantId previously supplied when creating a token for the first time for an entity.\nOnly required if re-submitting for a fresh token on a previously created applicant.\n",
            "type": "string",
            "x-omitempty": true
          },
          "applicationId": {
            "description": "If this is for a native application SDK, then we need the applicationId as reported by the SDK. This will then be tied to the token so it cannot be used in another application or handset.\n\nYou must send either an applicationID or a referrer (see below)\n",
            "type": "string",
            "x-omitempty": true
          },
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "referrer": {
            "description": "If this is for a web SDK, then you need to supply the referrer domain so that the token can be validated by the IDV service\n\nYou must send either a referrer or an applicationID (see above)\n",
            "type": "string",
            "x-omitempty": true
          }
        }
      },
      "EntityIDVResultObject": {
        "description": "Contains the results of a given document entity create/update and IDV token details.",
        "type": "object",
        "required": ["requestId", "entity", "token", "applicantId"],
        "properties": {
          "applicantId": {
            "description": "The applicantId is either the same one that was supplied in the request for a fresh token, or a new one.\nThis ID must be supplied along with the token to your SDK so that it knows who any uploaded documents are for.\n\nThe latest applicant will also be written to the extraData of the entity as well for safe keeping. Older applicantIds will be overwritten.\n",
            "type": "string"
          },
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "supportTwoDocs": {
            "description": "If the requesting customer can support requesting 2 documents.",
            "type": "boolean"
          },
          "token": {
            "description": "Token to be used in the SDK to authenticate the applicant and application/referrer.\n\nTokens are time limited (1 hour) and can only be used with the applicantId supplied.\n",
            "type": "string"
          }
        }
      },
      "EntityObject": {
        "description": "Describes all of the data being used to verify an entity.\n",
        "type": "object",
        "properties": {
          "addresses": {
            "description": "Collection of address objects.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AddressObject"
            },
            "x-omitempty": true
          },
          "dateOfBirth": {
            "$ref": "#/components/schemas/DOBObject"
          },
          "entityId": {
            "description": "When an entity is first created, it is assigned an ID. When updating an entity, make sure you set the entityId\nOne exception to this is when an entity is created from a document object. It is expected that this object would be passed into a /check or /entity call to set it.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "entityProfile": {
            "description": "If the entity is using the new profiles feature, then their profile name will be found here.\n\nNote: If setting a profile, you must ensure that the profile matches a known configuration.\n\nSee here for valid values:\n  https://docs.frankieone.com/docs/test-entity-verification\n",
            "type": "string",
            "x-omitempty": true
          },
          "entityType": {
            "$ref": "#/components/schemas/enumEntityType"
          },
          "extraData": {
            "description": "Set of key-value pairs that provide arbitrary additional type-specific data. You can use these fields to store external IDs, or other non-identity related items if you need to.\nIf updating an existing entity, then existing values with the same name will be overwritten. New values will be added.\n\nSee here for more information about possible values you can use:\n  https://docs.frankieone.com/docs/key-value-pairs\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyValuePairObject"
            },
            "x-omitempty": true
          },
          "flags": {
            "description": "Used to set additional information flags with regards to this entity and for ongoing processing.\n\nFlags might include having the entity (not) participate in regular pep/sanctions screening\nOthers will follow over time.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityFlagObject"
            },
            "x-omitempty": true
          },
          "gender": {
            "$ref": "#/components/schemas/enumGender"
          },
          "identityDocs": {
            "description": "Collection of identity documents (photos, scans, selfies, etc)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IdentityDocumentObject"
            },
            "x-omitempty": true
          },
          "name": {
            "$ref": "#/components/schemas/PersonalNameObject"
          },
          "organisationData": {
            "$ref": "#/components/schemas/OrganisationDataObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityObject"
        }
      },
      "EntityProfileAltKYCMatchResultObject": {
        "description": "Summary of all KYC matches for a given set of criteria\n",
        "type": "object",
        "properties": {
          "description": {
            "description": "A full description for these results",
            "type": "string"
          },
          "kycResults": {
            "description": "Summary of this alternative KYC match counts.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityProfileKYCMatchResultObject"
            },
            "x-omitempty": true
          },
          "name": {
            "description": "A short human readable name for these results",
            "type": "string"
          },
          "order": {
            "description": "For multiple matching criteria sets, the priority order in which this result set was defined.\n1 = highest priority criteria set\n2 = second highest priority\n...\nn = lowest priority\n",
            "type": "integer"
          },
          "result": {
            "description": "The current state of this alternative KYC check. One of:\n- PASS: Enough matches to pass.\n- FAIL: Not enough matches, zero or more, but less than required.\n- UNCHECKED: No results.\n",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityProfileAltKYCMatchResultObject"
        }
      },
      "EntityProfileCheckResultMessage": {
        "type": "object",
        "properties": {
          "checkClass": {
            "description": "The class of checks to which this check type belongs.\nOne of:\n- kyc\n- aml\n- fraud\n- none\n",
            "type": "string",
            "example": "kyc"
          },
          "checkType": {
            "description": "A single check type that this result message applies to.",
            "type": "string",
            "example": "one_plus"
          },
          "code": {
            "description": "Alphanumeric code that is unique for each failure message to simplify result processing and display. Values to be decided.\n",
            "type": "string"
          },
          "message": {
            "description": "Short description of why not passed",
            "type": "string",
            "example": "Partial match"
          },
          "name": {
            "description": "A short human readable name for the check type.",
            "type": "string",
            "example": "1+1"
          },
          "result": {
            "description": "The current state of the check. One of:\n- PASS\n- FAIL\n- UNCHECKED: Not attempted or service not available. For example AML not attempted if KYC fails.\n- NA: Not required. For example Visa check when there is no visa document and your account configuration indicates the check can be skipped.\n",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityProfileCheckResultMessage"
        }
      },
      "EntityProfileItemMatchResultObject": {
        "description": "Match summary for a single checked address or document",
        "type": "object",
        "properties": {
          "checked": {
            "description": "True if an attempt was made to verify",
            "type": "boolean",
            "example": true
          },
          "matchCount": {
            "description": "The number of distinct sources that matched this address or document",
            "type": "integer",
            "example": 5
          },
          "matchSources": {
            "description": "List of sources that matched. The matchCount will be the number of entries in this list.\n",
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "matchType": {
            "description": "The match type that this count and result refer to. For document matches this will be \"gov_id\" or \"other_id\". For addresses ir will be \"curr_addr\" or \"prev_addr\" depending on the status of the address at the time of the check.\n",
            "type": "string",
            "example": "gov_id"
          },
          "nonmatchSources": {
            "description": "List of sources that did not match, only if available from service provider.\n",
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "verified": {
            "description": "True if there is at least one match",
            "type": "boolean",
            "example": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityProfileItemMatchResultObject"
        }
      },
      "EntityProfileKYCMatchResultObject": {
        "description": "Summary of all KYC matches for a given set of criteria\n",
        "type": "object",
        "properties": {
          "matchCount": {
            "description": "Number of matches for this set of match types. In other words the sum of the matchCounts in the matchTypes map. Note that for match sets that include government ID (gov_id) this will not neccessaily be the count of matched sources.\n",
            "type": "integer",
            "example": 2
          },
          "matchCountRequired": {
            "description": "Number of distinct matches (sources and/or matched government ID documents) required for this set of match types.\n",
            "type": "integer",
            "example": 1
          },
          "matchTypes": {
            "description": "The match types that this overall count and result refer to. Currently one or more of:\n- name\n- address\n- dob\n- gender\n- gov_id\n- other_id\n\nThese will be keys in a map whose values hold the values for the individual match types. The resultant structure would look like the following. Here dob has zero matches and is not verfied but it was check, so other than the checked flag the value object is simply empty. A completely empty object would imply that match type was not checked.\n\n    \"matchTypes\": {\n      \"address\": {\n        \"matchCount\": 1,\n        \"matchSources\": [ \"au-elec-roll\" ],\n        \"checked\": true,\n        \"verified\": true\n      },\n      \"dob\": {\n        \"checked\": true\n      }\n    }\n\nSo for a one_plus KYC check there will be two EntityProfileKYCMatchResultObject records. One for 'name' and one for 'address, dob' (like the sample above).\n",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/EntityProfileKYCMatchResultObjectMatchTypes"
            },
            "x-omitempty": true
          },
          "verified": {
            "description": "True if there are enough matches to meet the requirement",
            "type": "boolean",
            "example": false
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityProfileKYCMatchResultObject"
        }
      },
      "EntityProfileKYCMatchResultObjectMatchTypes": {
        "type": "object",
        "properties": {
          "checked": {
            "description": "True if an attempt was made to verify",
            "type": "boolean",
            "example": true
          },
          "matchCount": {
            "description": "Number of distinct matches for this match type. Note that for government ID (gov_id) this is the count of matched documents, not sources.\n",
            "type": "integer",
            "example": 1
          },
          "matchSources": {
            "description": "List of sources that matched. Note that the matchCount is not always a count of the matchSources. Particularly for gov_id, the count is the number of distinct documents matched, not the number of sources.\n",
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "nonmatchSources": {
            "description": "List of sources that did not match, only if available from service provider.\n",
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "verified": {
            "description": "True if there is at least one match",
            "type": "boolean",
            "example": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityProfileKYCMatchResultObjectMatchTypes"
        }
      },
      "EntityProfileResultObject": {
        "description": "Contains the results of a check against an entity profile. \n\nThe entityProfileResult will be returned instead of a checkSummary to provide the full details of the verification process.\n",
        "type": "object",
        "properties": {
          "actionRecommended": {
            "description": "The recommended onboarding action for this entity after the profile check this result refers to. The action can also be an entity state set by you.\n- UNCHECKED: New entity with no checks applied\n- PASS\n- FAIL\n- PASS_MANUAL: Manual intervention was applied to achieve a pass\n- FAIL_MANUAL: Manual intervention was applied but the entity still fails\n- REFER: Manual intervention required\n- WAIT: Externally applied state, waiting for more entity details\n- ARCHIVED: Externally applied state, entity hidden from on onboarding list\n- INACTIVE: Externally applied state, entity hidden from on onboarding list, indexes and further changes will be blocked.\n",
            "type": "string"
          },
          "addressResults": {
            "description": "KYC match counts for each checked address, whether matched or not. The keys in this map are the address IDs. The match type in the value will be either \"curr_addr\" or \"prev_addr\". The resultant structure would look like:\n\n    \"addressResults\": {\n      \"addressId\": {\n        \"matchType\": \"curr_addr\",\n        \"matchCount\": 5,\n        \"verified\": true\n      },\n      \"addressId\": {\n        \"matchType\": \"prev_addr\",\n        \"matchCount\": 5,\n        \"verified\": true\n      }\n    }\n",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/EntityProfileItemMatchResultObject"
            },
            "x-omitempty": true
          },
          "alternativeKycResults": {
            "description": "Collections of KYC match counts.\n\nIf your recipe / entity profile contains KYC checks with multiple matching criteria, then the results of each criteria\nset will be here.\n\nThe first item will be the best result (out of PASS, FAIL or UNCHECKED), if there is a tie then the first item will be\nthe one with the highest priority (lowest order number, see EntityProfileAltKYCMatchResultObject). The first item will\nalso be in the EntityProfileResultObject kycResults, but but without the extra attributes from\nEntityProfileAltKYCMatchResultObject (name, description, order, result).\n\nThe items after the first will be the remaining alternatives in priority order (i.e. lowest order value to highest).\n\nNote: This will only be populated if you have multiple matching criteria in your recipe/profile.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityProfileAltKYCMatchResultObject"
            },
            "x-omitempty": true
          },
          "checkId": {
            "$ref": "#/components/schemas/CheckIDObject"
          },
          "checkResults": {
            "description": "The basic result for each check type required for the profile.\n\nThe results are listed in the order they are run so you can also see how far progressed through a check process you are.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityProfileCheckResultMessage"
            },
            "x-omitempty": true
          },
          "checkType": {
            "description": "Comma separated list of checks required for the entity profile.",
            "type": "string",
            "example": "two_plus,id,pep_media"
          },
          "creditHeaderFailures": {
            "description": "List of vendors from failed credit header sources.",
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "documentResults": {
            "description": "KYC match counts for each checked document, whether matched or not. The keys in this map are the document IDs. The match type in the value will be either \"gov_id\" or \"other_id\". The resultant structure would look like:\n\ndocumentResults: {\n    \"documentId\" : {\n      \"matchType\": \"gov_id\",\n      \"matchCount\": 5,\n      \"verified\": true\n    },\n    \"documentId\": {\n      \"matchType\": \"other_id\",\n      \"matchCount\": 5,\n      \"verified\": true\n    }\n}\n",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/EntityProfileItemMatchResultObject"
            },
            "x-omitempty": true
          },
          "entityId": {
            "description": "Unique ID for the entity.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "issueList": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "kycResults": {
            "description": "Summary of primary KYC match counts.\n\nIf you have a recipe that includes multiple potential matching criteria, then this will be the first set of criteria that matched.\nIf the KYC matches failed overall, then this will be the first matching criteria set in the list.\n\nAll potential matching criteria sets (including this one) will be included in the alternativeKycResults array\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityProfileKYCMatchResultObject"
            },
            "x-omitempty": true
          },
          "latestCheckDate": {
            "description": "The date and time of the last check that contributed to this result.",
            "type": "string",
            "format": "date-time",
            "example": "2018-11-12T13:14:15Z+10:00"
          },
          "manualIntervention": {
            "description": "Indicates if any manual actions have been involved in the check result.",
            "type": "boolean"
          },
          "policyName": {
            "description": "The name of the policy within the profile used for this check. This may or may not incorporate the 'riskPolicy' that is also an attribute in this object.",
            "type": "string",
            "example": "SDD U18"
          },
          "profileName": {
            "description": "The name of the profile used for this check.",
            "type": "string",
            "example": "Credit"
          },
          "resolverRecommended": {
            "description": "Workflow hint by arrangement with Frankie",
            "type": "string"
          },
          "riskLevel": {
            "description": "Risk level. One of: \n- LOW, \n- MEDIUM, \n- HIGH, \n- UACCEPTABLE \n- or UNKNOWN\n",
            "type": "string",
            "example": "LOW"
          },
          "riskPolicy": {
            "description": "Risk policy. Contents depend on account configuration but would typically be one of: \n- SDD, \n- CDD, \n- EDD \n- or FAIL\n",
            "type": "string",
            "example": "SDD"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityProfileResultObject"
        }
      },
      "EntityReportResultObject": {
        "description": "The following fields represent the fields needed in order to retrieve the downloadable link and its expiry date.\n",
        "type": "object",
        "properties": {
          "documentId": {
            "description": "The document id where the report is saved in the entity.\n",
            "type": "string",
            "format": "uuid"
          },
          "entityId": {
            "description": "The entityId that this report was generated from.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "linkExpiry": {
            "description": "Timestamp when the link expires.\n",
            "type": "string",
            "format": "date-time"
          },
          "linkURL": {
            "description": "Downloadable link to the report.\n",
            "type": "string"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "scanDocId": {
            "description": "The doc scan id where the report is saved in the document.\n",
            "type": "string",
            "format": "uuid"
          }
        }
      },
      "EntityResultObject": {
        "description": "Contains the results of a given document entity create/update or GET request.",
        "type": "object",
        "required": ["requestId", "entity"],
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EntityResultObject"
        }
      },
      "EntitySearchResultListItem": {
        "description": "Contains the individual search results for an entity.",
        "type": "object",
        "properties": {
          "confidence": {
            "$ref": "#/components/schemas/SearchResultConfidenceObject"
          },
          "customerChildID": {
            "description": "Customer Child ID that this result belongs to.\n",
            "type": "string",
            "format": "uuid"
          },
          "customerID": {
            "description": "Customer ID that this result belongs to.\n",
            "type": "string",
            "format": "uuid"
          },
          "documentMatchTypes": {
            "description": "Array of descriptons of document field matches used to score this search. This is a summary for all the documents for the matched entity.\n",
            "type": "array",
            "items": {
              "type": "string",
              "example": "ID number"
            },
            "x-omitempty": true
          },
          "documentNameMismatches": {
            "description": "If this entity has any level of name match then this is an array of document IDs for the entity where the document has an entity name and it doesn't match any entity names being sought.\n",
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid",
              "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
            },
            "x-omitempty": true
          },
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "entityMatchTypes": {
            "description": "Array of descriptons of entity field matches used to score this search.\n",
            "type": "array",
            "items": {
              "type": "string",
              "example": "Full name"
            },
            "x-omitempty": true
          }
        }
      },
      "EntitySearchResultObject": {
        "description": "Contains the results of a given entity search.",
        "type": "object",
        "required": ["requestId"],
        "properties": {
          "entitySearchResults": {
            "description": "The list of (potentially) matching entities with confidence levels.\n\nIf you are the \"owner\" of the entity - i.e. the same CustomerID and CustomerChildID (if relevant) - then by default the full details of the entity and any owned documents will be returned, except for the contents of any attached scans.\n\nIf you are not the owner of the entity (or linked documents), then just the ID and confidence level is returned. You can still use this ID to retrieve any check results (see GET  /entity/{entityId}/checks and GET /document/{documentId}/checks)\n\nIf the onlyEntityIds query parameter was set in the search request, then only the IDs and confidence levels will be return in either case.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntitySearchResultListItem"
            },
            "x-omitempty": true
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "totalEntitiesMatched": {
            "description": "The number of entity matches, which may be more than are included in these results if the resultLimit query parameter was used or a hard limit on results was reached..",
            "type": "integer",
            "example": 1234
          }
        }
      },
      "enumAddressType": {
        "description": "Used to indicate what sort address this is, such as residential, business, postal, etc.\n\nRESIDENTIAL1-4 can be used to indicate the reverse chronological order of addresses. \nRESIDENTIAL or RESIDENTIAL1 is the current address\nRESIDENTIAL2 is the previous address, and so on.\n\nFor Individual postal/mailing addresses, use POSTAL.\nFor Businesses, use OFFICIAL_CORRESPONDANCE\n",
        "type": "string",
        "enum": [
          "OTHER",
          "RESIDENTIAL",
          "RESIDENTIAL1",
          "RESIDENTIAL2",
          "RESIDENTIAL3",
          "RESIDENTIAL4",
          "BUSINESS",
          "POSTAL",
          "REGISTERED_OFFICE",
          "PLACE_OF_BUSINESS",
          "OFFICIAL_CORRESPONDANCE",
          "PLACE_OF_BIRTH"
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumAddressType"
        },
        "example": "REGISTERED_OFFICE"
      },
      "enumBackgroundCheckFrequency": {
        "description": "How often these checks run.",
        "type": "string",
        "enum": ["ADHOC", "YEARLY", "QUARTERLY", "MONTHY", "WEEKLY", "DAILY"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumBackgroundCheckFrequency"
        },
        "example": "DAILY"
      },
      "enumBackgroundCheckState": {
        "description": "Current state, based on the most recent check.\n- \"CLEAR\": The no checks have ever turned up results\n- \"PAST_HITS\": Past checks have returned hits, but now they're clear.\n- \"POSSIBLE_HIT\": The most recent checks turned up some results that may be relevant\n- \"ACTIVE_HITS\": The current checks are returning definitive hits.\n",
        "type": "string",
        "enum": ["CLEAR", "PAST_HITS", "POSSIBLE_HIT", "ACTIVE_HITS"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumBackgroundCheckState"
        },
        "example": "CLEAR"
      },
      "enumBackgroundCheckType": {
        "description": "Different types of checks available. \nNote: WATCHLIST can also cover PEP and/or SANCTION as well, depending on source provider used. GROUP is an internal 'meta-check' to store the group details for an AMLResultSet.\n",
        "type": "string",
        "enum": ["PEP", "SANCTION", "WATCHLIST", "MEDIA", "GROUP"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumBackgroundCheckType"
        },
        "example": "PEP"
      },
      "EnumBlockingType": {
        "description": "Indicates the type of the blocking entity.\n",
        "type": "string",
        "enum": [
          "ORGANISATION_NOT_FOUND",
          "NO_SHAREHOLDERS_FOUND",
          "COUNTRY_NOT_SUPPORTED",
          "NON_BENEFICIAL_INDIVIDUAL",
          "NON_BENEFICIAL_ORGANISATION",
          "NON_BENEFICIAL_UNKNOWN",
          "CIRCULAR_REFERENCE",
          "ENTITY_TYPE_UNKNOWN",
          "OTHER",
          "INSUFFICIENT_MAX_CREDIT_COST"
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumBlockingType"
        }
      },
      "enumCheckResultManualStatus": {
        "description": "Indicates the status of a check result as set by a user.\n- \"UNKNOWN\": The user has not decided so the actual check result applies as normal.\n- \"TRUE_POSITIVE\": The check result has been acknowledged as correct but the final effect (accept/reject) has not been decided.\n- \"TRUE_POSITIVE_ACCEPT\": The check result is correct but will be ignored. This is also known as 'whitelisting'\n- \"TRUE_POSITIVE_REJECT\": The check result is correct and will be used.\n- \"FALSE_POSITIVE\": The check result is not applicable and will be ignored.\n- \"STALE\": The check result will become invisible, will not be considered\n  and will not count towards due diligence requirements.\n",
        "type": "string",
        "enum": [
          "UNKNOWN",
          "TRUE_POSITIVE",
          "TRUE_POSITIVE_ACCEPT",
          "TRUE_POSITIVE_REJECT",
          "FALSE_POSITIVE",
          "STALE"
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumCheckResultManualStatus"
        }
      },
      "enumCheckResultState": {
        "description": "Check state for an individual data point\n- \"UNCHECKED\": Check has not yet been performed\n- \"NOT_SUPPORTED\": the requested check type is not supported by this connector.\n- \"CHECKING\": Checks are underway. \n- \"UNPROCESSABLE\": The data supplied was unprocessable. \n- \"NO_MATCH\": All checks complete, no records found that matched the details supplied\n- \"CHECKED_PARTIAL_SUCCESS\": All checks complete, but only some succeeded.\n- \"CHECKED_SUCCESS_WITH_NOTES\": All checks complete, but there are some notes (e.g. PEP or sanctions).\n- \"CHECKED_SUCCESS_CLEAR\": All checks complete, no additional notes\n- \"CHECKED_FAILED\": All checks complete, but all failed.\n",
        "type": "string",
        "enum": [
          "UNCHECKED",
          "CHECKING",
          "UNPROCESSABLE",
          "NOT_SUPPORTED",
          "NO_MATCH",
          "CHECKED_PARTIAL_SUCCESS",
          "CHECKED_SUCCESS_WITH_NOTES",
          "CHECKED_SUCCESS_CLEAR",
          "CHECKED_FAILED"
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumCheckResultState"
        },
        "example": "CHECKED_PARTIAL_SUCCESS"
      },
      "enumDocumentStatus": {
        "description": "Current status of a document.\n- \"INITIALISING\": the state whilst you're uploading and updating\n- \"SCAN_IN_PROGRESS\": the state whilst it's being scanned. \n- \"DOC_SCANNED\": the document has been scanned and data extracted as best as possible. It's still possible to update the details and add more scans if you wish.\n- \"DOC_CHECKED\": the document has been used as part of a check that has been finalised in some way. You can no longer update this document and any attempt will generate an error.\n",
        "type": "string",
        "enum": [
          "INITIALISING",
          "SCAN_IN_PROGRESS",
          "DOC_SCANNED",
          "DOC_CHECKED"
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumDocumentStatus"
        },
        "example": "DOC_SCANNED"
      },
      "enumEntityType": {
        "description": "Indicates the type of an entity.\n- \"INDIVIDUAL\": An individual.\n- \"TRUST\": A trust.\n- \"ORGANISATION\": An organisation.\n",
        "type": "string",
        "enum": ["INDIVIDUAL", "TRUST", "ORGANISATION"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumEntityType"
        },
        "example": "ORGANISATION"
      },
      "enumFunctionStatus": {
        "description": "High level indication of the final disposition of a backgrounded function\n- \"COMPLETED\": the request completed (not that the final result is a success, just that we completed)\n- \"FAILED\": the request failed. \n- \"INCOMPLETE\": could not complete the request.\n",
        "type": "string",
        "enum": ["COMPLETED", "FAILED", "INCOMPLETE"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumFunctionStatus"
        },
        "example": "COMPLETED"
      },
      "enumGender": {
        "description": "Used to indicate of the entity in question is:\n- \"M\"ale \n- \"F\"emale\n- \"U\"nspecified\n- \"O\"ther (for want of a better option)\n",
        "type": "string",
        "enum": ["U", "F", "M", "O"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumGender"
        },
        "example": "F"
      },
      "enumIdType": {
        "description": "Valid ID types\n  - \"OTHER\": Generic document type. Unspecified.\n  - \"DRIVERS_LICENCE\": Driver's licence.\n  - \"PASSPORT\": Passport\n  - \"VISA\": Visa document (not Visa payment card)\n  - \"IMMIGRATION\": Immigration card\n  - \"NATIONAL_ID\": Any national ID card\n  - \"TAX_ID\": Any national tax identifier\n  - \"NATIONAL_HEALTH_ID\": Any national health program ID card (e.g. Medicare, NHS)\n  - \"CONCESSION\": State issued concession card\n  - \"HEALTH_CONCESSION\": State issued health specific concession card\n  - \"SENIORS_HEALTH_CONCESSION\": State issued health specific concession card for seniors\n  - \"PENSION\": State issued pension ID\n  - \"MILITARY_ID\": Military ID\n  - \"BIRTH_CERT\": Birth certificate\n  - \"CITIZENSHIP\": Citizenship certificate\n  - \"MARRIAGE_CERT\": Marriage certificate\n  - \"DEATH_CERT\": Death certificate\n  - \"NAME_CHANGE\": Name chage confirmation\n  - \"UTILITY_BILL\": Regulated utility bill, such as electricity, gas, etc\n  - \"BANK_STATEMENT\": Bank/card statement\n  - \"BANK_ACCOUNT\": Bank account\n  - \"INTENT_PROOF\": A proof of intent. Generally a photo/video, or a scanned letter\n  - \"ATTESTATION\": A document of attestation (e.g. Statutory Declaration). NOTE: these cannot be used as a supporting document\n  - \"SELF_IMAGE\": A \"selfie\" used for comparisions\n  - \"EMAIL_ADDRESS\": An email address\n  - \"MSISDN\": A mobile phone number\n  - \"DEVICE\": A device ID\n  - \"VEHICLE_REGISTRATION\": Vehicle registration number\n  - \"PROOF_OF_ADDRESS\": Can be any type of document that provides a proof of address\n  - \"HOUSE_REGISTRATION\": House registration document\n  - \"YELLOW_HOUSE_REGISTRATION\": Yellow House Registration Thor Ror 13\n  - \"WORK_PERMIT\": Work permit\n  - \"EMPLOYMENT_CERTIFICATE\": Certificate of employment\n  - \"NOTARY_PUBLIC_ID\": Notary Public Identification\n  - \"AVIATION_SECURITY_ID\": Aviation Security Identification\n  - \"MARITIME_SECURITY_ID\": Maritime Security Identification\nBusiness related documentation\n  - \"EXTERNAL_ADMIN\": Details of appointed administrator.\n  - \"CHARGES\": Details of any charges that have been laid against a company or director\n  - \"PRE_ASIC\": Any documents that are Pre-ASIC\n  - \"ANNUAL_RETURN\": Details of a company's annual return\n  - \"REPORT\": Frankie generated report.\n  - \"TRUST_DEED\": Corporate trust deed\n  - \"PARTNERSHIP_AGREEMENT\": Partnership agreement documents\n  - \"ADMIN_CHANGE\": Change of Administrator\n  - \"COMPANY_REPORT\": ASIC filed company reports\nSpecial document types\n  - \"CHECK_RESULTS\": A special document type for specifying results of checks completed other than through Frankie.\n",
        "type": "string",
        "enum": [
          "OTHER",
          "DRIVERS_LICENCE",
          "PASSPORT",
          "VISA",
          "IMMIGRATION",
          "NATIONAL_ID",
          "TAX_ID",
          "NATIONAL_HEALTH_ID",
          "CONCESSION",
          "HEALTH_CONCESSION",
          "SENIORS_HEALTH_CONCESSION",
          "PENSION",
          "MILITARY_ID",
          "BIRTH_CERT",
          "CITIZENSHIP",
          "MARRIAGE_CERT",
          "DEATH_CERT",
          "NAME_CHANGE",
          "MOBILE_PHONE",
          "UTILITY_BILL",
          "BANK_STATEMENT",
          "BANK_ACCOUNT",
          "INTENT_PROOF",
          "ATTESTATION",
          "SELF_IMAGE",
          "EMAIL_ADDRESS",
          "MSISDN",
          "DEVICE",
          "VEHICLE_REGISTRATION",
          "PROOF_OF_ADDRESS",
          "HOUSE_REGISTRATION",
          "YELLOW_HOUSE_REGISTRATION",
          "WORK_PERMIT",
          "EMPLOYMENT_CERTIFICATE",
          "NOTARY_PUBLIC_ID",
          "AVIATION_SECURITY_ID",
          "MARITIME_SECURITY_ID",
          "EXTERNAL_ADMIN",
          "CHARGES",
          "PRE_ASIC",
          "ANNUAL_RETURN",
          "REPORT",
          "TRUST_DEED",
          "PARTNERSHIP_AGREEMENT",
          "ADMIN_CHANGE",
          "COMPANY_REPORT",
          "CHECK_RESULTS"
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumIdType"
        },
        "example": "DRIVERS_LICENCE"
      },
      "enumKVPType": {
        "description": "Used to describe the contents of the KVP data. \n\nThe general.* and raw.* types are pretty much what they say on the tin. \n\nAll raw.* fields will be base64 encoded so as to not interfere with JSON structuring. These are useful for returning/storing large quantities of data that doesn't necessarily require processing now, or may be useful to a calling client.\n\nThe id.* and pii.* are used to indicate that this is data that can be used to create new document objects, or entities. They should also be treated with the utmost care and attention when it comes to securing them too.\n\nid.external can be used to capture an object's ID on an external service, and can potentially be searchable in the index \nNote - This is different from a result.id.\n\ndefunct is used to mark an existing KVP deleted when the value must be retained, for example for audit purposes.\n\nresult.* are used to capture response codes and transaction IDs from external services\n\nerror.* types can be used when processing a document that returns an error, but doesn't necessarily require a full blown error response.\n",
        "type": "string",
        "enum": [
          "defunct",
          "general.string",
          "general.integer",
          "general.float",
          "general.bool",
          "general.date",
          "general.datetime",
          "raw.json.base64",
          "raw.xml.base64",
          "raw.base64",
          "error.code",
          "error.message",
          "result.code",
          "result.id",
          "id.external",
          "id.number.primary",
          "id.number.additional",
          "id.msisdn",
          "id.email",
          "id.device",
          "pii.name.full",
          "pii.name.familyname",
          "pii.name.givenname",
          "pii.name.middlename",
          "pii.gender",
          "pii.address.longform",
          "pii.address.shortform",
          "pii.address.street1",
          "pii.address.street2",
          "pii.address.postalcode",
          "pii.address.town",
          "pii.address.suburb",
          "pii.address.region",
          "pii.address.state",
          "pii.address.country",
          "pii.dob",
          "transient.string"
        ],
        "example": "id.external",
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumKVPType"
        }
      },
      "enumMIMEType": {
        "description": "The standard MIME type of the file being uploaded. We'll double-check to be certain, but this can help speed things up",
        "type": "string",
        "enum": [
          "image/jpeg",
          "image/avif",
          "image/png",
          "image/gif",
          "image/webp",
          "image/tiff",
          "image/bmp",
          "image/heic",
          "image/heif",
          "application/zip",
          "application/x-zip",
          "application/x-zip-compressed",
          "application/x-tar",
          "application/x-rar-compressed",
          "application/x-gzip",
          "application/gzip",
          "application/x-bzip2",
          "application/x-7z-compressed",
          "application/pdf",
          "application/rtf",
          "application/postscript",
          "application/json",
          "audio/mpeg",
          "audio/m4a",
          "audio/x-wav",
          "audio/amr",
          "text/plain",
          "text/rtf",
          "application/msword",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          "application/vnd.ms-excel",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          "application/vnd.ms-outlook",
          "application/vnd.ms-powerpoint",
          "application/vnd.oasis.opendocument.text",
          "application/vnd.openxmlformats-officedocument.presentationml.presentation",
          "video/avi",
          "video/x-m4a",
          "video/mp4",
          "video/webm",
          "video/quicktime",
          "video/msvideo",
          "video/x-msvideo",
          "video/x-ms-wmv",
          "video/mpeg"
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumMIMEType"
        },
        "example": "image/png"
      },
      "enumNotificationType": {
        "description": "Indicates the type of notification being pushed.\n- \"FUNCTION\": A request that you previously backgrounded has completed and this is the notification that is it complete (success is another matter)\n- \"RESULT\": Like the FUNCTION notification, this tells you that a previously backgrounded request has completed, and that there is a set of results in the payload pointer.\n- \"EVENT\": There has been a stateful change in a document, entity or some other piece of data that we are holding/monitoring for you. This is an indication that you may wish to take some action.\n- \"ALERT\": Like the EVENT, except that the severity of the notification indicates that action is almost certainly required.\n",
        "type": "string",
        "enum": ["FUNCTION", "RESULT", "EVENT", "ALERT"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumNotificationType"
        }
      },
      "EnumPriceTierCode": {
        "description": "The price tier code for the document being ordered\n",
        "type": "string",
        "enum": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "Unknown"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumPriceTierCode"
        }
      },
      "enumScanDataRetrievalState": {
        "description": "The reason why the scanData in a response is missing.\n- \"NORMAL\": The scanData was retrieved and is included. If it is empty then it was never provided or was provided empty.\n- \"EXCLUDED\": The retrieval request was not for 'full' data, or the object has 'ScanDelete' set so the scanData is not included\n- \"FAILED\": The scanData could not be retrieved from the secure document store.\n\nThe enumScanDataRetrievalState will not usually be set in a request. If a ScannedDocumentObject in a response has a 'FAILED' retrieval state then that object should not be sent back in a future possible update. It should either be omitted or the original data should be resent if it is available from another source. However it is safe to send the object in an update with the state received in a response. Any state other than 'NORMAL' (or '') will cause the blank scanData to be ignored, but other fields in the object will be updated if needed.\n",
        "type": "string",
        "enum": ["NORMAL", "EXCLUDED", "FAILED"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumScanDataRetrievalState"
        },
        "example": "NORMAL"
      },
      "enumScanSide": {
        "description": "Describes if a scan is of the \"F\"ront or \"B\"ack of an ID. If not supplied, Front is always assumed.",
        "type": "string",
        "enum": ["F", "B"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumScanSide"
        },
        "example": "F"
      },
      "enumScanType": {
        "description": "Valid ID document scan general types.\n- \"PHOTO\": Any photo\n- \"VIDEO\": Any video\n- \"AUDIO\": Any audio\n- \"PDF\":   PDF or PS (may contain text, images or both)\n- \"DOC\":   Word doc, RTF, etc\n- \"ZIP\":   Any compressed file(s)\n",
        "type": "string",
        "enum": ["PHOTO", "VIDEO", "AUDIO", "PDF", "DOC", "ZIP"],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumScanType"
        },
        "example": "PDF"
      },
      "enumSearchResultConfidence": {
        "description": "Defines how close a match we were able to make based on search results.\n- \"LOW\": The item does match the minimum criteria given, but is potentially one of a number of possible hits\n- \"MEDIUM\": The item matches multiple search criteria, but there is still some potential ambiguity with other hits\n- \"HIGH\": Matches all given search criteria, but there were other potential hits\n- \"DEFINITE\": Was the only item to match all given search criteria.\n",
        "type": "string",
        "enum": ["LOW", "MEDIUM", "HIGH", "DEFINITE"],
        "example": "HIGH"
      },
      "enumTransactionStatusKYC": {
        "description": "transaction disposition based on risk, confidence and final check status",
        "type": "string",
        "enum": [
          "PASS",
          "REFER",
          "FAIL",
          "PASS_MANUAL",
          "WAIT",
          "FAIL_MANUAL",
          "BLOCK",
          "UNCHECKED",
          "ARCHIVED",
          "INACTIVE"
        ],
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "EnumTransactionStatusKYC"
        }
      },
      "ErrorObject": {
        "type": "object",
        "required": ["requestId", "errorCode", "errorMsg"],
        "properties": {
          "commit": {
            "description": "Server version indication",
            "type": "string",
            "example": "2af478ed"
          },
          "errorCode": {
            "description": "Frankie error code",
            "type": "string",
            "example": "CORE-5990"
          },
          "errorMsg": {
            "description": "Will describe the error",
            "type": "string",
            "example": "Everything went kaflooey. Stay clam."
          },
          "httpStatusCode": {
            "description": "Deprecated:\nHTTP status code. Same as that which is passed back in the header.\n",
            "type": "integer",
            "example": 501
          },
          "issues": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ErrorObjectIssues"
            },
            "x-omitempty": true
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ErrorObject"
        }
      },
      "ErrorObjectIssues": {
        "type": "object",
        "required": ["issueLocation"],
        "properties": {
          "issue": {
            "description": "Description of the problem",
            "type": "string",
            "example": "Invalid format. Must be YYYY-MM-DD"
          },
          "issueLocation": {
            "description": "Will describe the field or data location of the issue",
            "type": "string",
            "example": "dateOfBirth"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ErrorObjectIssues"
        }
      },
      "FraudCheckResultObject": {
        "description": "Collection of fraud check results for the entity.\n    \nContains fraud list and/or background result arrays. Other fraud check types will appear over time\n",
        "type": "object",
        "properties": {
          "fraudBackgroundCheckResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProcessResultObject"
            },
            "x-omitempty": true
          },
          "fraudDeviceResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProcessResultObject"
            },
            "x-omitempty": true
          },
          "fraudListResults": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProcessResultObject"
            },
            "x-omitempty": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "FraudCheckResultObject"
        }
      },
      "GenderCheckResultObject": {
        "type": "object",
        "properties": {
          "checkResult": {
            "$ref": "#/components/schemas/generalCheckResultArray"
          },
          "gender": {
            "$ref": "#/components/schemas/enumGender"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "GenderCheckResultObject"
        }
      },
      "generalCheckResultArray": {
        "description": "An array in reverse chronological order of all checks done on this data point for the given entity. Older checks may have been previously done by you or another institution, and if so, these will be listed.",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/generalCheckResultObject"
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "GeneralCheckResultArray"
        }
      },
      "generalCheckResultObject": {
        "description": "Contains the details of a check on a given data point",
        "type": "object",
        "properties": {
          "checkProcessResults": {
            "$ref": "#/components/schemas/ProcessResultObject"
          },
          "checkRequestedBy": {
            "description": "Who performed the check. If it was the calling customer, the value will be \"You\".\nIf it was another institution that has previously validated this data, then a generic description of their industry will be provided, such as \"Bank\", \"Insurance\", \"Other FI\".\n",
            "type": "string",
            "example": "Bank"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "GeneralCheckResultObject"
        }
      },
      "GoodsAndServicesTax": {
        "type": "object",
        "properties": {
          "effectiveFrom": {
            "type": "string",
            "format": "date-time"
          },
          "effectiveTo": {
            "type": "string",
            "format": "date-time"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "GoodsAndServicesTax"
        }
      },
      "HistoricalChange": {
        "type": "object",
        "properties": {
          "businessName": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "date": {
            "type": "string",
            "format": "date-time"
          },
          "entityStatus": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "goodsAndServicesTax": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "mainBusinessPhysicalAddress": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "mainName": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "mainTradingName": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "HistoricalChange"
        }
      },
      "IdentityDocumentCheckResultObject": {
        "description": "This object holds the identityDocument that was checked and the results associated with said checks.\nYou can also leave the checkResult blank/nil if there are no results for that identityDocument if you wish. \nThis is useful for returning results on a freshly crerated entity where the API user would want to confirm that the data has indeed been stored, and be able to capture relevant documentIds - perhaps to address issues as to why it wasn't checked.\n",
        "type": "object",
        "properties": {
          "checkResult": {
            "$ref": "#/components/schemas/generalCheckResultArray"
          },
          "idDocument": {
            "$ref": "#/components/schemas/IdentityDocumentObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "IdentityDocumentCheckResultObject"
        }
      },
      "IdentityDocumentObject": {
        "type": "object",
        "required": ["idType", "country"],
        "properties": {
          "country": {
            "description": "The ISO-3166-alpha3 country code of the issuing national. Once set, this cannot be changed.\n\nSee https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes for more\n",
            "type": "string",
            "example": "AUS"
          },
          "createdFromScan": {
            "description": "This document's data was initially created from scanned and processed images. The value cannot be set manually and any attempt to do so will just be ignored.\n",
            "type": "boolean",
            "readOnly": true,
            "example": true
          },
          "docScan": {
            "description": "Collection of one or more objects that describe scan(s) that need to be put through OCR or facial recognition. These should all be from the one ID document, such as front/back, or page 1, 2, 3, etc. You can upload multiple scans in a single call, or in multiple calls. \n\n  Note: if you do upload over multiple calls, make sure you include the documentId (see above), and indicate that this is happening with a \"more_data\" checkAction\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScannedDocumentObject"
            },
            "x-omitempty": true
          },
          "documentId": {
            "description": "When an ID document is created/uploaded, it is assigned a documentId. You'll see this in a successful response or successfully accepted response. This can then be referenced in subsequent calls if you're uploading more/updated data.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "documentStatus": {
            "$ref": "#/components/schemas/enumDocumentStatus"
          },
          "extraData": {
            "description": "Set of key-value pairs that provide ID type-specific data. If updating an existing document, then existing values with the same name will be overwritten. New values will be added.\n\nIf this document is scanned through OCR or similar processes, then extracted data will be found here (Some may be used to populate other fields like idNumber and idExpiry as well)\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyValuePairObject"
            },
            "x-omitempty": true
          },
          "idExpiry": {
            "description": "The expiry date of the document (if known) in YYYY-MM-DD format.",
            "type": "string",
            "format": "date",
            "example": "2020-02-01"
          },
          "idIssued": {
            "description": "The issued date of the document (if known) in YYYY-MM-DD format.",
            "type": "string",
            "format": "date",
            "example": "1972-11-04"
          },
          "idNumber": {
            "description": "The ID number of the document (if known).",
            "type": "string",
            "example": "123456789"
          },
          "idSubType": {
            "description": "The sub-type of identity document. Very document specific.",
            "type": "string"
          },
          "idType": {
            "$ref": "#/components/schemas/enumIdType"
          },
          "manuallyModified": {
            "description": "If this document was originally populated from scanned data, then manually adjusted (e.g. if the scan's results weren't 100% correct or data was missing), then this will be set to true. The value cannot be set manually and any attempt to do so will just be ignored.\n",
            "type": "boolean",
            "readOnly": true,
            "example": "false"
          },
          "region": {
            "description": "Regional variant of the ID (e.g. VIC drivers licence)\n\nYou should always use the local abbreviation for this.\nE.g.\n  - VIC for The Australian state of Victoria\n  - MA for the US state of Massachusetts\n  - etc\n",
            "type": "string",
            "example": "VIC"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "IdentityDocumentObject"
        }
      },
      "IndividualData": {
        "description": "x",
        "type": "object",
        "required": ["percent_owned", "beneficially_held", "role"],
        "properties": {
          "addresses": {
            "description": "List of all found addresses associated with this person\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AddressObject"
            }
          },
          "beneficially_held": {
            "description": "If describing an (ultimate) beneficial owner, then if any of the shared held are not benefially held, this field will be set to \"false\"\n",
            "type": "boolean",
            "example": true
          },
          "date_of_birth": {
            "description": "RFC3339 formatted date",
            "type": "string",
            "format": "date",
            "example": "1969-01-01"
          },
          "entityId": {
            "description": "The entityId of the individual\n",
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "description": "Name of the individual\n",
            "type": "string",
            "example": "JAN MICHAEL VINCENT"
          },
          "percent_owned": {
            "description": "If describing an (ultimate) beneficial owner, the percentage of the company owned by this Individual\n",
            "type": "number",
            "format": "float"
          },
          "role": {
            "description": "If this individual has a role as an officeholder, such as director, then this will be described here. May be blank.\n",
            "type": "string",
            "example": "Director"
          },
          "screening_result": {
            "$ref": "#/components/schemas/ScreeningResult"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "IndividualData"
        }
      },
      "IndustryCodesObject": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string"
          },
          "description": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "IndustryCodesObject"
        }
      },
      "IndustryDeclarationsObject": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "language": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "IndustryDeclarationsObject"
        }
      },
      "IndustryPaymentPredictor": {
        "type": "object",
        "properties": {
          "atbData": {
            "$ref": "#/components/schemas/AtbData"
          },
          "averageOverdue": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AverageOverdue"
            }
          },
          "displayStateAlert": {
            "type": "boolean"
          },
          "noGoodData": {
            "type": "boolean"
          },
          "othersAbnHistory": {
            "$ref": "#/components/schemas/OthersAbnHistory"
          },
          "overdueDays": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "example": "[10,6,6,7,7,7,7,7,7,9,6,6]"
          },
          "paymentPredictorNoEnoughData": {
            "type": "boolean"
          },
          "paymentPredictorPurchased": {
            "type": "boolean"
          },
          "tableOfStats": {
            "$ref": "#/components/schemas/TableOfStat"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "IndustryPaymentPredictor"
        }
      },
      "InsolvencyNotice": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "type": "string",
            "example": "c29341c0-eac5-11eb-8fed-0242ac11000e"
          },
          "lastmod": {
            "type": "string",
            "format": "date-time"
          },
          "publisher": {
            "type": "string",
            "example": "Address: Von, Towne and Blick of 25 Ronald Crescent, Boyne Island, Queensland 4680"
          },
          "reportedBy": {
            "type": "string",
            "example": "Address: Von, Towne and Blick of 25 Ronald Crescent, Boyne Island, Queensland 4680"
          },
          "ruling": {
            "type": "string",
            "example": "Corporations Act 2001  Paragraph 465A(1)(c)  Regulation 5.4.01A"
          },
          "title": {
            "type": "string",
            "example": "NOTICE OF APPLICATION FOR WINDING UP ORDER"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "InsolvencyNotice"
        }
      },
      "InternationalBusinessProfileCriteria": {
        "description": "Object to supply the country code and company code whose details you wish to retrieve.\n",
        "type": "object",
        "required": ["country"],
        "properties": {
          "company_code": {
            "description": "This is the company number returned in the search results\n\n(InternationalBusinessSearchResponse.Companies.CompanyDTO[n].Code)\n",
            "type": "string"
          },
          "country": {
            "description": "The ISO 3166-1 alpha2 country code of country registry you wish to search.\nThis is consistent for all countries except for:\n\n  - The United States which requires the state registry to query as well.\n    - As an example, for a Delaware query, the country code would be \"US-DE\".\n    - A Texas query would use \"US-TX\"\n  - Canada, which also requires you to supply a territory code too.\n    - A Yukon query would use CA-YU, Manitoba would use CA-MB\n    - You can do an all jurisdiction search with CA-ALL\n\n  See details here:\n    https://docs.frankieone.com/docs/country-codes-for-international-business-queries\n",
            "type": "string"
          },
          "registration_authority_code": {
            "description": "The registration authority code you wish to search on. This will be used when the country you are searching has multiple registration authorities.\n",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "InternationalBusinessProfileCriteria"
        }
      },
      "InternationalBusinessProfileResponse": {
        "description": "This wraps the search response details from Kyckr\n",
        "type": "object",
        "properties": {
          "CompanyProfile": {
            "$ref": "#/components/schemas/CompanyProfileDTO"
          },
          "checkId": {
            "description": "Unique ID for the individual check that was run.\n",
            "type": "string",
            "format": "uuid"
          },
          "entityCreatedDate": {
            "description": "The date and time this entity was created in our service.\n",
            "type": "string",
            "format": "date-time"
          },
          "entityId": {
            "description": "If the response was successful and we returned a company profile, we save this as an ORGANISATION type entity in our service.\nWe will also save the profile result as a REPORT type document, attached to the entity.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "entityUpdatedDate": {
            "description": "The date and time this entity was last updated in our service.\n",
            "type": "string",
            "format": "date-time"
          },
          "ibResponseCode": {
            "description": "service provider response code",
            "type": "integer"
          },
          "ibResponseDetails": {
            "type": "string"
          },
          "ibRetrievalLocation": {
            "type": "string"
          },
          "ibTransactionId": {
            "description": "service provider ID",
            "type": "string"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "InternationalBusinessProfileResponse"
        }
      },
      "InternationalBusinessSearchCriteria": {
        "description": "Object to supply the country code, business name and number, along with an optional registry parameter to search for.\n",
        "type": "object",
        "required": ["country"],
        "properties": {
          "cached_search": {
            "description": "Flag to use the cache search functionality of provider.\n",
            "type": "boolean"
          },
          "country": {
            "description": "The ISO 3166-1 alpha2 country code of country registry you wish to search.\nThis is consistent for all countries except for:\n\n  - The United States which requires the state registry to query as well.\n    - As an example, for a Delaware query, the country code would be \"US-DE\".\n    - A Texas query would use \"US-TX\"\n  - Canada, which also requires you to supply a territory code too.\n    - A Yukon query would use CA-YU, Manitoba would use CA-MB\n    - You can do an all jurisdiction search with CA-ALL\n\n  See details here:\n    https://docs.frankieone.com/docs/country-codes-for-international-business-queries\n",
            "type": "string"
          },
          "organisation_name": {
            "description": "Name or name fragment you wish to search for. \n\nNote: The less you supply, the more, but less relevant results will be returned.\n\nCRITICAL NOTE: This is *NOT* to be used as a progressive search function.\n\nYou must supply at least one of organisation_name and/or organisation_number.\nIf you supply both, a name search will be conducted first, then the number will be checked against the result set and any remaining results returned.\n",
            "type": "string"
          },
          "organisation_number": {
            "description": "The business number you wish to search on. This should be a unique corporate identifier as per the country registry you're searching.\n",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "InternationalBusinessSearchCriteria"
        }
      },
      "InternationalBusinessSearchResponse": {
        "description": "This wraps the search response details from Kyckr\n",
        "type": "object",
        "properties": {
          "Companies": {
            "$ref": "#/components/schemas/ArrayOfCompanyDTO"
          },
          "ibContinuationKey": {
            "type": "string"
          },
          "ibResponseCode": {
            "description": "service provider response code",
            "type": "integer"
          },
          "ibResponseDetails": {
            "type": "string"
          },
          "ibTransactionId": {
            "description": "service provider ID",
            "type": "string"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "InternationalBusinessSearchResponse"
        }
      },
      "IssueList": {
        "$ref": "#/components/schemas/IssueListImpl"
      },
      "IssueListImpl": {
        "description": "Array of issues associated with this monitoring alert. Same contents as the case record alert list but as an array rather thand a string. The alert list will become deprecated at some point.\n  \nList of possible issues supported:\n    \n* 404\n* 500\n* ATT-IDV\n* ATT-NCMP\n* ATT-PHT\n* BANK ACCOUNT\n* BL\n* DUP\n* FRAUD\n* IWL\n* M\n* PEP\n* PTL\n* RISK\n* S\n* VISA\n* WL\n",
        "type": "object",
        "x-go-type": {
          "import": {
            "package": "github.com/lib/pq"
          },
          "type": "StringArray"
        }
      },
      "IssueListItems": {
        "description": "A key/value pair of strings that describe the location of the issue (key) and an issue description (value). Also inclused is a severity\n",
        "type": "object",
        "properties": {
          "issue_description": {
            "description": "Human readable description of the issue\n",
            "type": "string",
            "example": "Date of birth not found"
          },
          "issue_location": {
            "description": "Where the issue occured. It will describe a location in the response structure\n",
            "type": "string",
            "example": "ultimate_beneficial_owner.0.date_of_birth"
          },
          "issue_severity": {
            "description": "The impact of the issue on the process. \n\nIs it just informational, such as a trivial different in a name match?\nIs it a warning to highlight something that is important, but did not prevent the process from completing?\nIs it a critical issue that prevented the check from completing successfully?\nIs it a stop condition that prevented the checks from being run at all?\n",
            "type": "string",
            "enum": ["INFO", "WARN", "CRIT", "STOP"]
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "IssueListItems"
        }
      },
      "KVPOArray": {
        "description": "Set of key-value pairs that provide additional data. This is *not* the extra data from the entity.\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/KeyValuePairObject"
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "KVPOArray"
        },
        "x-omitempty": true
      },
      "KYBMonitorNotification": {
        "description": "Message bus payload for fo.kyb.monitor.notifications topic\n",
        "type": "object",
        "required": ["registrationNumbers"],
        "properties": {
          "createdDate": {
            "description": "The UTC date this notication applies to",
            "type": "string",
            "format": "date"
          },
          "description": {
            "description": "The 'issue' from CW daily-notification\n",
            "type": "string"
          },
          "notificationType": {
            "description": "The 'type' from CW daily-notification\n",
            "type": "string"
          },
          "registeredName": {
            "description": "The 'organisationName' from CW daily-notification\n",
            "type": "string"
          },
          "registrationNumbers": {
            "$ref": "#/components/schemas/KYBRegistrationNumbers"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "KYBMonitorNotification"
        }
      },
      "KYBMonitorRun": {
        "description": "Message bus payload for fo.kyb.monitor.runs topic\n",
        "type": "object",
        "properties": {
          "pollDate": {
            "description": "The UTC date for which the monitor poll should be done. Default is the current UTC day.",
            "type": "string",
            "format": "date"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "KYBMonitorRun"
        }
      },
      "KYBMonitorStatus": {
        "description": "Message bus payload for fo.kyb.monitor.requests & responses topics\n",
        "type": "object",
        "required": ["registrationNumbers"],
        "properties": {
          "monitoringEnabled": {
            "type": "boolean",
            "x-omitempty": false
          },
          "registrationNumbers": {
            "$ref": "#/components/schemas/KYBRegistrationNumbers"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "KYBMonitorStatus"
        }
      },
      "KYBRegistrationNumbers": {
        "type": "object",
        "additionalProperties": {
          "type": "string"
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "KYBRegistrationNumbers"
        },
        "x-omitempty": true
      },
      "KYCScreeningResult": {
        "description": "The results of a safe harbour KYC check of an individual\n",
        "type": "object",
        "required": [
          "name_match_count",
          "dob_match_count",
          "address_match_count"
        ],
        "properties": {
          "address_match_count": {
            "description": "The number of address matches",
            "type": "integer",
            "example": 1
          },
          "check_result": {
            "description": "The disposition of the 2+2 Safe Harbour check\n",
            "type": "string",
            "enum": ["NOT_SCREENED", "PASS", "REFER", "FAIL"],
            "example": "PASS"
          },
          "dob_match_count": {
            "description": "The number of date of birth matches",
            "type": "integer",
            "example": 1
          },
          "matching_sources": {
            "description": "The is of matching data sources that produced a success match for the person being screened\nExample given is not indicative of the actual sources available.\n",
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": ["au-elec", "ntd", "dvs"]
          },
          "name_match_count": {
            "description": "The number of name matches",
            "type": "integer",
            "example": 2
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "KYCScreeningResult"
        }
      },
      "KeyValuePairObject": {
        "description": "Individual key-value pair",
        "type": "object",
        "properties": {
          "kvpKey": {
            "description": "Name of the data",
            "type": "string",
            "example": "ACN"
          },
          "kvpType": {
            "$ref": "#/components/schemas/enumKVPType"
          },
          "kvpValue": {
            "description": "Value of the data",
            "type": "string",
            "example": "406655338"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "KeyValuePairObject"
        }
      },
      "LegalFormDTO": {
        "type": "object",
        "properties": {
          "Basis": {
            "type": "string"
          },
          "Capital": {
            "type": "string"
          },
          "Comments": {
            "type": "string"
          },
          "Control": {
            "type": "string"
          },
          "Incorp": {
            "type": "string"
          },
          "Partner": {
            "type": "string"
          },
          "Responsibility": {
            "type": "string"
          },
          "Stocks": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "LegalFormDTO"
        }
      },
      "ListOfString": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ListOfString"
        }
      },
      "Loan": {
        "type": "object",
        "properties": {
          "abn": {
            "type": "string"
          },
          "acn": {
            "type": "string"
          },
          "amount": {
            "type": "string"
          },
          "companyName": {
            "type": "string"
          },
          "endAt": {
            "type": "string",
            "format": "date-time"
          },
          "startAt": {
            "type": "string",
            "format": "date-time"
          },
          "status": {
            "type": "string"
          },
          "termLength": {
            "type": "integer"
          },
          "type": {
            "type": "string"
          },
          "uuid": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "Loan"
        }
      },
      "MainBusinessPhysicalAddress": {
        "type": "object",
        "properties": {
          "effectiveFrom": {
            "type": "string",
            "format": "date-time"
          },
          "effectiveTo": {
            "type": "string",
            "format": "date-time"
          },
          "postcode": {
            "type": "string"
          },
          "stateCode": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "MainBusinessPhysicalAddress"
        }
      },
      "MercantileEnquiry": {
        "type": "object",
        "properties": {
          "agent": {
            "type": "string"
          },
          "company": {
            "type": "string"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time"
          },
          "date": {
            "type": "string",
            "format": "date-time"
          },
          "phone": {
            "type": "string"
          },
          "registeredDate": {
            "type": "string",
            "format": "date-time"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "MercantileEnquiry"
        }
      },
      "NonIndividualBeneficialOwner": {
        "description": "x",
        "type": "object",
        "required": ["percent_owned", "beneficially_held"],
        "properties": {
          "beneficially_held": {
            "description": "If describing an (ultimate) beneficial owner, then if any of the shared held are not benefially held, this field will be set to \"false\"\n",
            "type": "boolean",
            "example": true
          },
          "entity_type": {
            "description": "The ASIC type of the company/entity",
            "type": "string",
            "example": "APUB"
          },
          "name": {
            "description": "Name of the company/entity",
            "type": "string",
            "example": "Widget Trust Corpoation Inc."
          },
          "percent_owned": {
            "description": "If describing an (ultimate) beneficial owner, the percentage of the company owned\n",
            "type": "number",
            "format": "float"
          },
          "stock_exchange_data": {
            "$ref": "#/components/schemas/StockExchangeData"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "NonIndividualBeneficialOwner"
        }
      },
      "NotificationResultObject": {
        "description": "The following fields represent the data you need in order to retrieve the results of the requested function. See the details of the notification API for more.\n",
        "type": "object",
        "properties": {
          "checkId": {
            "description": "If you're calling a processing function of some kind, a check number will be issued. This field will only be present if the function you're calling would normally return a checkId (such as scan, verify, and compare).\n",
            "type": "string",
            "format": "uuid"
          },
          "documentId": {
            "description": "Only supplied if the original request was tied to a document. This will be the same ID that was sent in the original acceptance.\n",
            "type": "string",
            "format": "uuid"
          },
          "entityCustomerReference": {
            "description": "If the entity in entityId above has had an external service ID attached to it in the entity extraData with kvpKey = customer_reference, then this is that kvpValue\n",
            "type": "string",
            "example": "AU0123456"
          },
          "entityId": {
            "description": "Only supplied if the original request was tied to an entity. This will be the same ID that was sent in the original acceptance.\n",
            "type": "string",
            "format": "uuid"
          },
          "extraData": {
            "description": "Additional fields that contain the detailed data that was used to generate the 'message' field. The actual content\nwill depend on the 'notificationType' and 'function'.\n",
            "type": "object",
            "additionalProperties": true
          },
          "function": {
            "description": "Short description of the original function called, or function that was triggered.\n",
            "type": "string",
            "example": "entity.create"
          },
          "functionResult": {
            "$ref": "#/components/schemas/enumFunctionStatus"
          },
          "linkReference": {
            "description": "URI for resource containing more details about the reason for the notification.\n",
            "type": "string",
            "format": "uri",
            "example": "https://portal.frankiefinancial.io/entity/3fa85f64-5717-4562-b3fc-2c963f66afa6"
          },
          "message": {
            "description": "A brief, human readable message describing the reason for the notification.\n",
            "type": "string",
            "example": "Entity successfully created"
          },
          "notificationType": {
            "$ref": "#/components/schemas/enumNotificationType"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "username": {
            "description": "The portal username that initiated the operation that led to this notification. If applicable and available.\n",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "NotificationResultObject"
        }
      },
      "OfficerObject": {
        "description": "Officer details as returned from an ASIC report.",
        "type": "object",
        "properties": {
          "addedBy": {
            "description": "If this officer was created from a request for a manual association, then this is the identity of the\nparty that requested that association. For requests via the Frankie portal this will default to the portal\nusername. Otherwise, if not given in the request, this will be your company name.\n",
            "type": "string"
          },
          "appointmentDate": {
            "type": "string",
            "format": "date"
          },
          "ceasedDate": {
            "type": "string",
            "format": "date",
            "nullable": true
          },
          "countryOfResidence": {
            "type": "string"
          },
          "courtDetails": {
            "$ref": "#/components/schemas/CourtDetailsObject"
          },
          "directorId": {
            "type": "string"
          },
          "directorships": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DirectorshipsObject"
            },
            "x-omitempty": true
          },
          "docNumber": {
            "type": "string"
          },
          "docNumberQualifier": {
            "type": "string"
          },
          "entityId": {
            "type": "string",
            "format": "uuid"
          },
          "nationality": {
            "type": "string"
          },
          "natureOfControl": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "status": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "type": {
            "type": "string"
          },
          "typeDescription": {
            "type": "string"
          },
          "unstructuredAppointmentDate": {
            "type": "string"
          },
          "unstructuredCeasedDate": {
            "type": "string"
          },
          "unstructuredNotifiedDate": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OfficerObject"
        }
      },
      "OrganisationCheckResponseObject": {
        "description": "The result of an /business/ownership/query call retrieved via GET /retrieve/response/{requestId} after you receive a notification that the result is ready.\n",
        "type": "object",
        "properties": {
          "flags": {
            "description": "Used to set additional information flags for this response.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityFlagObject"
            },
            "example":"kyb_target",
            "x-omitempty": true
          },
          "organisationCheckId": {
            "description": "Batch identifier for the KYC/AML check results if any.\n",
            "type": "string",
            "format": "uuid"
          },
          "organisationCheckResult": {
            "$ref": "#/components/schemas/OrganisationCheckResultObject"
          },
          "ownershipCheckDate": {
            "description": "If an ownership result is provided in this response then this is the date and time the service provided that result.\n",
            "type": "string",
            "format": "date-time"
          },
          "ownershipCheckId": {
            "description": "Unique identifier for the ownership check.\n",
            "type": "string",
            "format": "uuid"
          },
          "ownershipQueryError": {
            "$ref": "#/components/schemas/ErrorObject"
          },
          "ownershipQueryResult": {
            "$ref": "#/components/schemas/OwnershipQueryResultObject"
          },
          "reportError": {
            "$ref": "#/components/schemas/ErrorObject"
          },
          "reportResult": {
            "$ref": "#/components/schemas/BusinessReportResultObject"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "uboResponse": {
            "$ref": "#/components/schemas/UBOResponse"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OrganisationCheckResponseObject"
        }
      },
      "OrganisationCheckResultObject": {
        "description": "The results of KYC/AML check on a organisation with a prior ownership query. This will be retrived via GET /retrieve/response/{requestId} after you receive a notification that the results are ready.\n",
        "type": "object",
        "properties": {
          "entityCategories": {
            "description": "A map of the entity categories that were selected for checks and an array of the entity IDs for each. The results for each entity ID will be in either the entityCheckResults or entityCheckErrors maps. Entities may appear in more than one category.\n",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            },
            "x-omitempty": true
          },
          "entityCheckErrors": {
            "description": "A map of outright errors (failure to generate any kind of result). These objects will be referenced by entity ID in the entity category map.\n",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ErrorObject"
            },
            "x-omitempty": true
          },
          "entityCheckResults": {
            "description": "List of all entities check results (both individuals and organisations) other than outright errors. These objects will be referenced by entity ID in the entity category map.\n",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/CheckEntityCheckResultObject"
            },
            "x-omitempty": true
          },
          "entityId": {
            "description": "The entityId of the organisation for which this result was created.\n",
            "type": "string",
            "format": "uuid"
          },
          "groupId": {
            "description": "The unique ID for grouping all new KYC/AML checks in this result. This is only for Frankie internal use.\n",
            "type": "string",
            "format": "uuid"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OrganisationCheckResultObject"
        }
      },
      "OrganisationDataObject": {
        "description": "Organisation details for entities. Returned from an ASIC report.\n",
        "type": "object",
        "properties": {
          "adverseCreditDataPresent": {
            "type": "boolean"
          },
          "aliases": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "class": {
            "$ref": "#/components/schemas/CodeDescription"
          },
          "contactDetails": {
            "$ref": "#/components/schemas/OrganisationDataObjectContactDetails"
          },
          "disclosingEntityIndicator": {
            "type": "boolean"
          },
          "extractedDate": {
            "type": "string",
            "format": "date",
            "nullable": true
          },
          "includesNonBeneficiallyHeld": {
            "type": "boolean"
          },
          "industryCodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IndustryCodesObject"
            },
            "x-omitempty": true
          },
          "industryDeclarations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IndustryDeclarationsObject"
            },
            "x-omitempty": true
          },
          "kycCustomerType": {
            "type": "string"
          },
          "lastCheckDate": {
            "type": "string",
            "format": "date"
          },
          "legalFormDetails": {
            "$ref": "#/components/schemas/OrganisationDataObjectLegalFormDetails"
          },
          "normalisedLegalStatus": {
            "type": "string"
          },
          "ownershipResolved": {
            "type": "boolean"
          },
          "registeredName": {
            "type": "string"
          },
          "registration": {
            "$ref": "#/components/schemas/OrganisationDataObjectRegistration"
          },
          "registries": {
            "$ref": "#/components/schemas/Registries"
          },
          "reviewDate": {
            "type": "string",
            "format": "date",
            "nullable": true
          },
          "shareStructure": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ShareStructureObject"
            },
            "x-omitempty": true
          },
          "startDate": {
            "type": "string",
            "format": "date"
          },
          "status": {
            "$ref": "#/components/schemas/CodeDescription"
          },
          "subType": {
            "$ref": "#/components/schemas/CodeDescription"
          },
          "subclass": {
            "$ref": "#/components/schemas/CodeDescription"
          },
          "type": {
            "$ref": "#/components/schemas/CodeDescription"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OrganisationDataObject"
        }
      },
      "OrganisationDataObjectBlockingReason": {
        "type": "object",
        "properties": {
          "candidates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BlockingReasonCandidate"
            },
            "x-omitempty": true
          },
          "description": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OrganisationDataObjectBlockingReason"
        }
      },
      "OrganisationDataObjectContactDetails": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string"
          },
          "faxNumber": {
            "type": "string"
          },
          "telephoneNumber": {
            "type": "string"
          },
          "websiteURL": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OrganisationDataObjectContactDetails"
        }
      },
      "OrganisationDataObjectLegalFormDetails": {
        "type": "object",
        "properties": {
          "basis": {
            "type": "string"
          },
          "capital": {
            "type": "string"
          },
          "comments": {
            "type": "string"
          },
          "control": {
            "type": "string"
          },
          "incorp": {
            "type": "string"
          },
          "partner": {
            "type": "string"
          },
          "responsibility": {
            "type": "string"
          },
          "stocks": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OrganisationDataObjectLegalFormDetails"
        }
      },
      "OrganisationDataObjectRegistration": {
        "type": "object",
        "properties": {
          "countryIso": {
            "type": "string"
          },
          "date": {
            "type": "string",
            "format": "date"
          },
          "number": {
            "type": "string"
          },
          "previousNumber": {
            "type": "string"
          },
          "registryCode": {
            "type": "string"
          },
          "registryDescription": {
            "type": "string"
          },
          "state": {
            "type": "string"
          },
          "unstructuredDate": {
            "type": "string"
          },
          "unstructuredFoundationDate": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OrganisationDataObjectRegistration"
        }
      },
      "OthersAbnHistory": {
        "type": "object",
        "properties": {
          "getSingleHighestCreditExtended": {
            "type": "integer"
          },
          "tradeHistory": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TradeHistory"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OthersAbnHistory"
        }
      },
      "OwnershipBlockingDetailsObject": {
        "type": "object",
        "properties": {
          "entityId": {
            "type": "string",
            "format": "uuid"
          },
          "entityType": {
            "$ref": "#/components/schemas/enumEntityType"
          },
          "percentageOwned": {
            "type": "object",
            "properties": {
              "beneficially": {
                "type": "number"
              },
              "isBeneficialNearZero": {
                "description": "Indicates if the beneficially held percentage is negligible.",
                "type": "boolean"
              },
              "isContainingJointOwnership": {
                "description": "Indicates if the percentage held contains a jointly held percentage.\n",
                "type": "boolean"
              },
              "isNonBeneficialNearZero": {
                "description": "Indicates if the non-beneficially held percentage is negligible.",
                "type": "boolean"
              },
              "isTotalNearZero": {
                "description": "Indicates if the total percentage is negligible.",
                "type": "boolean"
              },
              "nonBeneficially": {
                "type": "number"
              },
              "total": {
                "type": "number"
              }
            }
          },
          "reasons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OwnershipBlockingReasonObject"
            },
            "x-omitempty": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OwnershipBlockingDetailsObject"
        }
      },
      "OwnershipBlockingReasonObject": {
        "type": "object",
        "properties": {
          "candidates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BlockingReasonCandidate"
            },
            "x-omitempty": true
          },
          "circularEntityIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "x-omitempty": true
          },
          "description": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/EnumBlockingType"
          },
          "unstructuredType": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OwnershipBlockingReasonObject"
        }
      },
      "OwnershipDetailsObject": {
        "description": "The ownership details for one organisation.\n",
        "type": "object",
        "properties": {
          "beneficialOwners": {
            "description": "The beneficial owners of the company, who aren't necessarily UBO's.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BeneficialOwnerObject"
            },
            "x-omitempty": true
          },
          "officers": {
            "description": "Company office holders.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OfficerObject"
            },
            "x-omitempty": true
          },
          "organisation": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "shareCapitalGroup": {
            "description": "This provides information about the different categories or types of shares issued by the company.\n",
            "type": "object",
            "properties": {
              "shareCapital": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ShareCapitalObject"
                },
                "x-omitempty": true
              },
              "totalNumberOfShares": {
                "description": "The total number of shares issued by the organisation of all types.\n",
                "type": "integer"
              },
              "totalShareCapitalValue": {
                "type": "string"
              }
            }
          },
          "shareholdings": {
            "description": "Parcels of shares held by one or more shareholders.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ShareholdingObject"
            },
            "x-omitempty": true
          },
          "staticBeneficialOwners": {
            "description": "The beneficial owners of the company that were added directly via the Frankie API, not from an authoritative business registry.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BeneficialOwnerObject"
            },
            "x-omitempty": true
          },
          "staticOfficers": {
            "description": "The officers or other associated entity roles for the company that were added directly via the Frankie API, not from an authoritative business registry.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OfficerObject"
            },
            "x-omitempty": true
          },
          "ultimateBeneficialOwners": {
            "description": "The ultimate beneficial owners of the company.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BeneficialOwnerObject"
            },
            "x-omitempty": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OwnershipDetailsObject"
        }
      },
      "OwnershipPolicy": {
        "description": "The policy that was used to determine the ownership of the organisation. Includes UBO and blocking thresholds and blocking definitions.\n",
        "type": "object",
        "properties": {
          "blockingDefinitions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "blockingThreshold": {
            "type": "number",
            "format": "float"
          },
          "uboThreshold": {
            "type": "number",
            "format": "float"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OwnershipPolicy"
        }
      },
      "OwnershipQuery": {
        "description": "Details of the organisation for which ownership should be queried. This should at least contain the ACN in the externalIds.\n",
        "type": "object",
        "required": ["organisation"],
        "properties": {
          "associations": {
            "description": "A list of manual associations you wish to make with the business to be queried.\n\nIf your configuration supports this (ask your customer success representative), you can potentially\ncompare any UBOs or office holders you supply against those found through local registries.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StaticEntityAssociationRequest"
            },
            "x-omitempty": true
          },
          "organisation": {
            "$ref": "#/components/schemas/EntityObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OwnershipQuery"
        }
      },
      "OwnershipQueryResponseObject": {
        "description": "Frankie internal use only.\n\nThe result of an /business/ownership/query call as returned by a suitable service connector.\n",
        "type": "object",
        "properties": {
          "checkDate": {
            "description": "If a result is provided in this response then this is the date and time the service provided that result.\n",
            "type": "string",
            "format": "date-time"
          },
          "checkId": {
            "type": "string",
            "format": "uuid"
          },
          "ownershipQueryResult": {
            "$ref": "#/components/schemas/OwnershipQueryResultObject"
          },
          "providerCheckId": {
            "description": "Unique identifier provided by the service.\n",
            "type": "string"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OwnershipQueryResponseObject"
        }
      },
      "OwnershipQueryResultObject": {
        "type": "object",
        "properties": {
          "associatedEntities": {
            "description": "List of all entities (both individuals and organisations) associated with this ownership result. These objects will be referenced by entityId in the shareholdings and officers lists in the following ownership details.\n",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/EntityObject"
            },
            "x-omitempty": true
          },
          "blockingEntityDetails": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/OwnershipBlockingDetailsObject"
            },
            "x-omitempty": true
          },
          "blockingEntityIds": {
            "description": "List of entity IDs (that should be in the associatedEntities list) who blocked the ultimate beneficial ownership tree traversal. These are likely to be entities that cannot be checked automatically (such as trusts) or who have no UBO's of their own, such as public companies.\n\nThe presence of data in this array also signifies that the full UBO list is not complete.\n",
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "x-omitempty": true
          },
          "entityCreatedDate": {
            "description": "The date and time this entity was created in our service.\n",
            "type": "string",
            "format": "date-time"
          },
          "entityId": {
            "description": "The entityId of the organisation for which this result was created. The details will be in the ownershipDetails map with this ID as the key.\n",
            "type": "string",
            "format": "uuid"
          },
          "entityUpdatedDate": {
            "description": "The date and time this entity was updated in our service.      \n",
            "type": "string",
            "format": "date-time"
          },
          "otherOwners": {
            "description": "A map of entityId to beneficialOwnerObjects that are not blocking and UBO entities.\n",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/BeneficialOwnerObject"
            },
            "x-omitempty": true
          },
          "ownershipDetails": {
            "description": "A map of entityId to ownershipDetailsObjects with at least one entry being for the root organisation that the overall result relates to. Any remaining entries will be for further results for organisational owners referenced in the root ownershipDetailsObject and so on.\n",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/OwnershipDetailsObject"
            },
            "x-omitempty": true
          },
          "ownershipPolicy": {
            "$ref": "#/components/schemas/OwnershipPolicy"
          },
          "uncategorisedEntities": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/EntityObject"
            },
            "x-omitempty": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "OwnershipQueryResultObject"
        }
      },
      "PSCDetails": {
        "type": "object",
        "properties": {
          "Address": {
            "type": "string"
          },
          "CeasedOn": {
            "type": "string"
          },
          "CountryOfResidence": {
            "type": "string"
          },
          "DOBDay": {
            "type": "integer",
            "format": "int64"
          },
          "DOBMonth": {
            "type": "integer",
            "format": "int64"
          },
          "DOBYear": {
            "type": "integer",
            "format": "int64"
          },
          "Kind": {
            "type": "string"
          },
          "Name": {
            "type": "string"
          },
          "Nationality": {
            "type": "string"
          },
          "NatureOfControl": {
            "$ref": "#/components/schemas/ArrayOfString"
          },
          "NatureOfControlList": {
            "$ref": "#/components/schemas/ListOfString"
          },
          "NotifiedOn": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "PSCDetails"
        }
      },
      "ParentAssociationsObject": {
        "description": "A list of direct parent associations of an entity\n",
        "type": "object",
        "properties": {
          "associations": {
            "description": "A list of direct associations\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssociationObject"
            }
          },
          "entityId": {
            "description": "The entityId of interest.\n",
            "type": "string",
            "format": "uuid"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ParentAssociationsObject"
        }
      },
      "ParentAssociationsQueryResult": {
        "description": "The result of an /business/{entityId}/parentAssociations call\n",
        "type": "object",
        "properties": {
          "parentAssociations": {
            "description": "A list of all parent associations of entity \n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ParentAssociationsObject"
            }
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ParentAssociationsQueryResult"
        }
      },
      "PaymentDefault": {
        "type": "object",
        "properties": {
          "abn": {
            "type": "string"
          },
          "accountAdditionalAbn": {
            "type": "string"
          },
          "accountVerifiedDate": {
            "type": "string",
            "format": "date-time"
          },
          "amountOutstanding": {
            "type": "number",
            "format": "float"
          },
          "approvedDate": {
            "type": "string",
            "format": "date-time"
          },
          "company": {
            "type": "string"
          },
          "defaultSettled": {
            "type": "boolean"
          },
          "doctype": {
            "type": "string"
          },
          "documentType": {
            "type": "string"
          },
          "lastUpdated": {
            "type": "string",
            "format": "date-time"
          },
          "originalInvoiceDate": {
            "type": "string",
            "format": "date-time"
          },
          "partPaymentMade": {
            "type": "boolean"
          },
          "partpayment": {
            "type": "boolean"
          },
          "paymentDueDate": {
            "type": "string",
            "format": "date-time"
          },
          "posterAbn": {
            "type": "string"
          },
          "posterName": {
            "type": "string"
          },
          "settled": {
            "type": "boolean"
          },
          "uploadedDate": {
            "type": "string",
            "format": "date-time"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "PaymentDefault"
        }
      },
      "PaymentPredictorHistoryItem": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "format": "date-time"
          },
          "daysBeyondTerms": {
            "type": "integer"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "PaymentPredictorHistoryItem"
        }
      },
      "PersonalNameCheckResultObject": {
        "type": "object",
        "properties": {
          "checkResult": {
            "$ref": "#/components/schemas/generalCheckResultArray"
          },
          "name": {
            "$ref": "#/components/schemas/PersonalNameObject"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "PersonalNameCheckResultObject"
        }
      },
      "PersonalNameObject": {
        "type": "object",
        "required": ["familyName"],
        "properties": {
          "displayName": {
            "description": "In some cases, the name will need to be supplied in \"long form\", such as when it is determined from a document scan, or is un-parsable in some way.\nThe service will attempt to convert it to it's constituent parts where possible.\n",
            "type": "string",
            "example": "Jane Cecily Smith"
          },
          "familyName": {
            "description": "Family name / Surname of the individual.",
            "type": "string",
            "example": "Smith"
          },
          "givenName": {
            "description": "First / Given name",
            "type": "string",
            "example": "Jane"
          },
          "honourific": {
            "description": "Mr/Ms/Dr/Dame/Dato/etc.",
            "type": "string",
            "example": "Duchess"
          },
          "middleName": {
            "description": "Middle name(s) / Initials",
            "type": "string",
            "example": "Cecily"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "PersonalNameObject"
        }
      },
      "ProcessResultObject": {
        "description": "Stores the generic results of a process (check, scan, compare, verify, etc)",
        "type": "object",
        "properties": {
          "checkDate": {
            "description": "The date and time the item was checked to provide this result.",
            "type": "string",
            "format": "date-time"
          },
          "checkId": {
            "$ref": "#/components/schemas/CheckIDObject"
          },
          "checkPerformedBy": {
            "description": "Service provider that performed the check. Basically the name of the connector, without the leading con_\n",
            "type": "string",
            "example": "dvs"
          },
          "checkSource": {
            "description": "Code that can be used to determine the underlying nature or data source of the checks performed. This may or may not be known by the connector, or may be a provider specific type (e.g. type \"O\")\n\nNote, this will actually be normalised by the core service into a standfardised result so that we're not accidentally counting sources twice.\nOriginal source will then be copied into the KVPs\n",
            "type": "string",
            "example": "DVS"
          },
          "checkType": {
            "description": "Short indication of the type of check that was done. \n\nWhen used as a summary, it will the the checkType that was requested\n\nFor granular results, it will be the individual check performed.\n",
            "type": "string"
          },
          "confidenceLevel": {
            "description": "Confidence in the result on a scale of 0 (no match) to 100 (strong/identical match). Whole integers only.\n\nNegative values are used to indicate untrusted results.\n",
            "type": "integer",
            "format": "int32",
            "maximum": 100,
            "minimum": 0,
            "example": 70
          },
          "providerCheckID": {
            "description": "The service provider will give us a receipt, transaction id, check number, or some such that gives us a unique id on their side that we can reconcile with\n",
            "type": "string"
          },
          "resultNotes": {
            "description": "Any additional notes that may relate to the state. These are returned as typed KVPs",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyValuePairObject"
            },
            "x-omitempty": true
          },
          "resultState": {
            "$ref": "#/components/schemas/enumCheckResultState"
          },
          "riskLevel": {
            "description": "Only supplied in a summary result. Used to indicate the ovall risk score for the entity at this point in time, based on configurable rules.\n\nSome examples might include:\n\n  * Current level of ID checks passed\n  * Device ID scores\n  * Current PEP/Sanctions/etc checks\n  * Jurisdictional risk based on addresses, documents and other KVPs\n  * Fraud check results\n  \nIn this case a higher score is a bad thing. General rule of thumb:\n\n  * 0 - 30 = Low Risk\n  * 31 - 50 = Medium Risk\n  * 50 - 75 = High Risk\n  * 75+ = Unacceptable\n",
            "type": "integer",
            "maximum": 100,
            "minimum": 0,
            "example": 75
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ProcessResultObject"
        }
      },
      "PuppyObject": {
        "description": "All valid customers get a puppy. Otherwise, no puppy for you!",
        "type": "object",
        "required": ["puppy"],
        "properties": {
          "asknicely1": {
            "type": "string"
          },
          "asknicely2": {
            "type": "string"
          },
          "asknicely3": {
            "type": "string"
          },
          "asknicely4": {
            "type": "string"
          },
          "asknicely5": {
            "type": "string"
          },
          "asknicely6": {
            "type": "string"
          },
          "asknicely7": {
            "type": "string"
          },
          "commit": {
            "description": "Server version indication",
            "type": "string",
            "example": "2af478ed"
          },
          "puppy": {
            "type": "boolean",
            "default": true,
            "example": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "PuppyObject"
        }
      },
      "Registries": {
        "type": "object",
        "properties": {
          "abr": {
            "$ref": "#/components/schemas/Abr"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "Registries"
        }
      },
      "RegulatoryInformation": {
        "type": "object",
        "properties": {
          "licence_details": {
            "type": "string"
          },
          "licence_number": {
            "type": "string"
          },
          "licence_verified": {
            "type": "boolean"
          },
          "regulatory_body": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "RegulatoryInformation"
        }
      },
      "ReportCreditReport": {
        "type": "object",
        "properties": {
          "courtJudgements": {
            "description": "CreditorWatch aggregate data from courts around Australia to provide a summary of court actions against an entity. When available, details of the action include location, case number, state, plaintiff, nature of the claim, action type and dollar amount.",
            "type": "array",
            "title": "Court Actions",
            "items": {
              "$ref": "#/components/schemas/CourtJudgement"
            }
          },
          "creditEnquiries": {
            "description": "Credit enquiries provide an indication of the number of times an entity's credit file has been accessed.",
            "type": "integer",
            "title": "Credit Enquiries",
            "example": 201
          },
          "insolvencyNotices": {
            "description": "Insolvency and other published notices are provided by ASIC.\nThese published notices provide details on external administrations, winding up applications (voluntary or by a court) and proposed company deregistrations, amongst other things.\nThe notices contain important contact details and dates for creditors.\nThese notices are provided directly from the ASIC insolvency notices website.\nIf you require further information, visit: \n\n  https://insolvencynotices.asic.gov.au.",
            "type": "array",
            "title": "Insolvency Notices",
            "items": {
              "$ref": "#/components/schemas/InsolvencyNotice"
            }
          },
          "loans": {
            "type": "array",
            "title": "Loans",
            "items": {
              "$ref": "#/components/schemas/Loan"
            }
          },
          "mercantileEnquiries": {
            "description": "A Mercantile enquiry is an indication that a mercantile agency (or debt collection agency) has conducted an enquiry on this entity for the purpose of debt collection.",
            "type": "array",
            "title": "Mercantile Enquiries",
            "items": {
              "$ref": "#/components/schemas/MercantileEnquiry"
            }
          },
          "paymentDefaults": {
            "description": "A default indicates that the debtor has failed to make a payment for goods or services. Payment Defaults are unique to CreditorWatch and  can have one of three statuses:\n\n  - outstanding\n  - partial payment\n  - settled.\n",
            "type": "array",
            "title": "Payment Defaults",
            "items": {
              "$ref": "#/components/schemas/PaymentDefault"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ReportCreditReport"
        }
      },
      "ReportCreditScore": {
        "type": "object",
        "properties": {
          "creditScore": {
            "type": "object",
            "properties": {
              "abn": {
                "type": "string"
              },
              "acn": {
                "type": "string"
              },
              "description": {
                "type": "string"
              },
              "itemCode": {
                "type": "string"
              },
              "scores": {
                "$ref": "#/components/schemas/CreditScoreObject"
              }
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ReportCreditScore"
        }
      },
      "ReportDetail": {
        "description": "The results of the available report.\n",
        "type": "object",
        "properties": {
          "availableFormats": {
            "type": "string"
          },
          "expectedDeliveryTimeMinutes": {
            "description": "The expected delivery time is in minutes. The report will be available for download once this period is elapsed\n",
            "type": "integer"
          },
          "extraData": {
            "description": "Set of key-value pairs that provide arbitrary additional type-specific data. You can use these fields to store external IDs, or other non-identity related items if you need to.\nIf updating an existing entity, then existing values with the same name will be overwritten. New values will be added.\n\nSee here for more information about possible values you can use:\n  https://docs.frankieone.com/docs/key-value-pairs\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KeyValuePairObject"
            }
          },
          "priceTierCode": {
            "$ref": "#/components/schemas/EnumPriceTierCode"
          },
          "provider": {
            "description": "The name of the service provider that generated the report.\n",
            "type": "string"
          },
          "reportCode": {
            "description": "If the report provider generated an ID or recipt number for the report, it goes here",
            "type": "string"
          },
          "reportTitle": {
            "description": "The title of the requested report",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ReportDetail"
        }
      },
      "ReportPaymentPredictor": {
        "type": "object",
        "properties": {
          "industryPaymentPredictor": {
            "$ref": "#/components/schemas/IndustryPaymentPredictor"
          },
          "paymentPredictorHistory": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PaymentPredictorHistoryItem"
            }
          },
          "paymentPredictorStats": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TableOfStat"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ReportPaymentPredictor"
        }
      },
      "RequestIDObject": {
        "description": "Unique identifier for every request. Can be used for tracking down answers with technical support. \n\nUses the ULID format (a time-based, sortable UUID)\n\nNote: this will be different for every request.\n",
        "type": "string",
        "format": "ulid",
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "RequestIDObject"
        },
        "example": "01BFJA617JMJXEW6G7TDDXNSHX"
      },
      "RetrievedResponseObject": {
        "description": "When sent a notification or alert, you'll call the /retrive/response/{requestId} function\n\nThis will return the original response\n",
        "type": "object",
        "properties": {
          "origHTTPstatus": {
            "description": "This will be the HTTP response code that was returned originally (200, 404, etc). \n\nIn the case where you're requesting the result of a callback (previously backgrounded call), then this is the response that would have been sent, had you waited for the call to finish.\n",
            "type": "integer"
          },
          "payload": {
            "description": "This is a placeholder field. It will actually be a JSON object that is the payload that would have been returned (or was returned) in the original request. You'll need to process this as if it were the original response, and act accordingly.\n",
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "ScannedDocumentObject": {
        "description": "the document to be attached and optionally scanned (if supported)",
        "type": "object",
        "properties": {
          "ScanDelete": {
            "description": "Used as a way of indicating to the service that the original scanned document is not to be kept after it has been processed. We will retain any metadata and the results of processing (where required by regulation or the customer), but the original file uploaded will eventually be remnoved once processing is complete. \n\nIf ScanDelete is set to true, any call with /full at the end will still not return the file contents, regardless of whether the file has been deleted yet (the deletion process is a background task that can take a few minutes to occur)\n",
            "type": "boolean"
          },
          "scanCreated": {
            "description": "The date and time the scan was created. Not the date of the scanned document, which should be in the idIssued attribute of the document that owns this scan.\n",
            "type": "string",
            "format": "date-time",
            "example": "2020-06-02"
          },
          "scanData": {
            "description": "Base64 encoded string of a photo or scan of an ID document to be verified. If supplied and of a supported type, the Frankie service will attempt to use OCR tech to extract the data from the scanned doc/image.\n\nIn a result message, this field will be left blank, unless the \"full\" action is requested.\n",
            "type": "string",
            "format": "byte",
            "example": "VGhpcyBpcyBzb21lIGV4YW1wbGUgZGF0YS4gV29vLCBJIGJldCB5b3UgcmVncmV0IHRoZSB0aW1lIHlvdSB3YXN0ZWQgZGVjb2RpbmcgdGhpcywgaHVoPw=="
          },
          "scanDataRetrievalState": {
            "$ref": "#/components/schemas/enumScanDataRetrievalState"
          },
          "scanDocId": {
            "description": "When an document scan is created/uploaded, it is assigned a scanDocId. You'll see this in a successful response or successfully accepted response. This can then be referenced in subsequent calls if you're uploading more/updated data.\n",
            "type": "string",
            "format": "uuid",
            "example": "84a9a860-68ae-4d7d-9a53-54a1116d5051"
          },
          "scanFilename": {
            "description": "If you're uploading a file where it's important to keep the original filename, then you can provide that here. Otherwise the Frankie service will assign an arbitrary name based on the scanDocIdand an extension based on the MIME type\n",
            "type": "string",
            "example": "Important Document - ID1234567.pdf"
          },
          "scanMIME": {
            "$ref": "#/components/schemas/enumMIMEType"
          },
          "scanPageNum": {
            "description": "If uploading multiple pages - it's handy to keep a track of these. There is no enforcement of these numbers at all. You can have 10 page 1's and a page 29 if you wish.\n",
            "type": "integer",
            "minimum": 0,
            "example": 1
          },
          "scanSide": {
            "$ref": "#/components/schemas/enumScanSide"
          },
          "scanType": {
            "$ref": "#/components/schemas/enumScanType"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ScannedDocumentObject"
        }
      },
      "ScreeningResult": {
        "description": "Contains the results (if any) of the KYC and AML/Media checks performed\n",
        "type": "object",
        "properties": {
          "aml_result": {
            "$ref": "#/components/schemas/AMLScreeningResult"
          },
          "kyc_result": {
            "$ref": "#/components/schemas/KYCScreeningResult"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ScreeningResult"
        }
      },
      "SearchResultConfidenceObject": {
        "description": "Provides details of the confidence level we have that this is the item we're looking for.\n",
        "type": "object",
        "properties": {
          "level": {
            "$ref": "#/components/schemas/enumSearchResultConfidence"
          },
          "notes": {
            "description": "Free-form list of descriptions around any partial matches\n",
            "type": "array",
            "items": {
              "type": "string"
            },
            "x-omitempty": true
          },
          "score": {
            "description": "Numeric score on a scale of 0 (none) to 100 (as certain as possible) on which the confidence level is based. Whole integers only.",
            "type": "integer",
            "format": "int32",
            "maximum": 100,
            "minimum": 0,
            "example": 70
          }
        }
      },
      "ShareCapitalObject": {
        "description": "Details of a share capital as returned from an ASIC report.",
        "type": "object",
        "properties": {
          "amount": {
            "type": "string"
          },
          "amountDue": {
            "type": "string"
          },
          "classCode": {
            "description": "This will contain a specific code assigned to the class of shares.\n",
            "type": "string"
          },
          "classTitle": {
            "description": "This is a more descriptive field of the class of shares.\n",
            "type": "string"
          },
          "currency": {
            "type": "string"
          },
          "detailsType": {
            "description": "This field can be used classify and identify the nature of supplementary information related to the specific class of shares.\n",
            "type": "string"
          },
          "documentNumber": {
            "description": "This is the specific identification number of the document linked to the class of shares.\n",
            "type": "string"
          },
          "documentNumberQualifier": {
            "description": "This provides further information regarding the document number linked to the class of shares.\n",
            "type": "string"
          },
          "numberOfShares": {
            "description": "The actual number of shares issued in the specific class type.\n",
            "type": "integer"
          },
          "totalAmountDueAndPayable": {
            "description": "This denotes the total monetary value that is due and payable in this particular class of shares.\n",
            "type": "integer"
          },
          "totalAmountPaid": {
            "description": "This denotes the total monetary value that is invested in this particular class of shares.\n",
            "type": "integer"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ShareCapitalObject"
        }
      },
      "ShareStructureObject": {
        "description": "Describes a collection of shares of a particular type and their attributes,\nOne or more ShareStructures make up a company's shares that are then parcelled out as shareholdings.\n",
        "type": "object",
        "properties": {
          "amountDue": {
            "type": "number"
          },
          "amountPaid": {
            "type": "number"
          },
          "classCode": {
            "type": "string"
          },
          "classTitle": {
            "type": "string"
          },
          "docNumber": {
            "type": "string"
          },
          "docNumberQualifier": {
            "type": "string"
          },
          "sharesIssued": {
            "type": "integer"
          },
          "status": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ShareStructureObject"
        }
      },
      "ShareholderDetails": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "allInfo": {
            "type": "string"
          },
          "currency": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "nationality": {
            "type": "string"
          },
          "nominalValue": {
            "type": "string"
          },
          "percentage": {
            "type": "string"
          },
          "shareClass": {
            "type": "string"
          },
          "shareCount": {
            "type": "integer",
            "format": "int64"
          },
          "shareType": {
            "type": "string"
          },
          "shareholderType": {
            "type": "string"
          },
          "totalShareCount": {
            "type": "integer",
            "format": "int64"
          },
          "totalShareValue": {
            "type": "integer",
            "format": "int64"
          },
          "totalShares": {
            "type": "integer",
            "format": "int64"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ShareholderDetails"
        }
      },
      "ShareholderSummary": {
        "type": "object",
        "properties": {
          "shareCapital": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ShareholderSummary"
        }
      },
      "ShareholdingObject": {
        "description": "Details of a shareholding as returned from an ASIC report.",
        "type": "object",
        "properties": {
          "allInfo": {
            "type": "string"
          },
          "beneficiallyOwned": {
            "type": "boolean"
          },
          "currency": {
            "type": "string"
          },
          "docNumber": {
            "type": "string"
          },
          "docNumberQualifier": {
            "type": "string"
          },
          "fullyPaid": {
            "type": "boolean"
          },
          "holderType": {
            "type": "string"
          },
          "jointHolding": {
            "type": "boolean",
            "nullable": true
          },
          "members": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "x-omitempty": true
          },
          "nominalValue": {
            "type": "string"
          },
          "nonBeneficiallyOwned": {
            "type": "boolean",
            "nullable": true
          },
          "numberHeld": {
            "type": "integer"
          },
          "percentageHeld": {
            "$ref": "#/components/schemas/BeneficialOwnerObjectPercentageHeld"
          },
          "shareCapitalClassCode": {
            "type": "string"
          },
          "totalShareCount": {
            "type": "integer"
          },
          "totalShareValue": {
            "type": "number"
          },
          "totalShares": {
            "type": "integer"
          },
          "type": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "ShareholdingObject"
        }
      },
      "StaticEntityAssociationRequest": {
        "description": "A request to create or update an association between an entity and a parent organisation.\n",
        "type": "object",
        "properties": {
          "addedBy": {
            "description": "Identity of the party that requested this association. For requests via the Frankie portal this\nwill default to the portal username. Otherwise, if not given, this will be your company name.\n",
            "type": "string"
          },
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "percentageHeld": {
            "description": "The details of the entity's ownership of the organisation.\n\nThe percentage held is optional, but at least one of role and percentage held must be included. If the percentage held\nis null or omitted, then any existing ownership for the entity will be retained. If the percentage held is given, then\nthe percentage held for the entity will be replaced, not merged.\n\nThe currently assigned ownership percentages can be found in the business ownership query results, in the ownership details for the organisation, in the\nstaticBeneficialOwners array.\n",
            "type": "object",
            "properties": {
              "beneficially": {
                "type": "number"
              },
              "jointly": {
                "type": "number"
              },
              "nonBeneficially": {
                "type": "number"
              }
            }
          },
          "roles": {
            "description": "The roles are optional in an association request, but at least one of roles and percentage held must be included. If the roles object is omitted, then\nany existing roles for the entity will be retained. To delete all roles for the entity use an empty roles array ([]). When updating roles, all the current\nroles for the entity must be included. They can be obtained from the business ownership query results, by going through the officers array in the ownership\ndetails for the organisation and extracting records with the ID of the entity and a non-blank 'addedBy' field.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StaticEntityAssociationRole"
            },
            "x-omitempty": false
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "StaticEntityAssociationRequest"
        }
      },
      "StaticEntityAssociationResponse": {
        "description": "The positive result of an entity association change request.\n",
        "type": "object",
        "properties": {
          "entity": {
            "$ref": "#/components/schemas/EntityObject"
          },
          "percentageHeld": {
            "$ref": "#/components/schemas/BeneficialOwnerObjectPercentageHeld"
          },
          "requestId": {
            "$ref": "#/components/schemas/RequestIDObject"
          },
          "roles": {
            "description": "The current entity association roles.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StaticEntityAssociationRole"
            },
            "x-omitempty": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "StaticEntityAssociationResponse"
        }
      },
      "StaticEntityAssociationRole": {
        "description": "A role describing the association between an entity and a parent organisation\n",
        "type": "object",
        "properties": {
          "type": {
            "description": "A short type codes for the role, f.ex \"DR\" (Director), \"SR\" (Secretary), \"OTH\" (Other).\nThere can only be one association role of each type for each associated entity in an organisation. The types must be between from two to four uppercase letters and digits.\nNote that some types (including \"DR\" and \"SR\") have special meanings when it comes to reporting, identity checks and risk calculations, so use them with caution.\n",
            "type": "string"
          },
          "typeDescription": {
            "description": "A description of the type of association between the entity and the organisation. The description must not be blank. The description for each type can include multiple titles if required.\n\n\"roles\": [\n    {\n        \"type\": \"DR\",\n        \"description\": \"CEO & CFO\"\n    },\n        \"type\": \"OTH\",\n        \"description\": \"Wunderkind\"\n    }\n]\n",
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "StaticEntityAssociationRole"
        }
      },
      "StockExchangeData": {
        "description": "If a company is listed, then this object will be populated with whatever data has been determined.\n",
        "type": "object",
        "properties": {
          "approved_exchange": {
            "type": "boolean"
          },
          "exchange": {
            "type": "string"
          },
          "exchange_ticker": {
            "type": "string"
          },
          "supporting_document_links": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "supporting_evidence_in_pdf": {
            "type": "boolean"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "StockExchangeData"
        }
      },
      "SuppliedData": {
        "description": "The data that was initially supplied to check in the batch file\n",
        "type": "object",
        "required": [
          "name",
          "company_type",
          "acn",
          "abn",
          "customer_reference"
        ],
        "properties": {
          "abn": {
            "description": "Australian Business Number - MUST be 11 digits. Can be supplied in lieu of the ACN\n",
            "type": "string",
            "example": 99001234321
          },
          "acn": {
            "description": "Australian Company Number on file - MUST be zero left-padded to 9 digits\n",
            "type": "string",
            "example": 342225
          },
          "company_type": {
            "description": "The type of company on file. Use the ABR's company types, as given here:\n\nhttps://abr.business.gov.au/Documentation/ReferenceData (entity types)\n",
            "type": "string",
            "enum": ["PRV", "PUB"]
          },
          "customer_reference": {
            "description": "Your reference number for this company",
            "type": "string",
            "example": "WBC000ABC123"
          },
          "name": {
            "description": "The name of the company to be verified\n",
            "type": "string",
            "example": "Worldwide Widget Pty. Ltd."
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "SuppliedData"
        }
      },
      "SuppliedDataMatches": {
        "description": "The results of the comparison of the supplied data (above) to that found on file with the ABR.\nIf the value is missing, then the comparison was not run. There will likely be an issue highlighted in the issues_list\n",
        "type": "object",
        "required": ["matched_name", "matched_acn", "matched_company_type"],
        "properties": {
          "matched_acn": {
            "description": "Did the supplied ACN match the ACN on file with the ABR? Only truly relevant if ABN is supplied as well.\n",
            "type": "boolean",
            "example": true
          },
          "matched_company_type": {
            "description": "Did the supplied company type match the company type on file with the ABR?\n",
            "type": "boolean",
            "example": true
          },
          "matched_name": {
            "description": "Did the supplied name match (or closely match) the name on file with the ABR\n",
            "type": "boolean",
            "example": true
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "SuppliedDataMatches"
        }
      },
      "TableOfStat": {
        "type": "object",
        "properties": {
          "averageBalance": {
            "type": "number",
            "format": "float",
            "example": 76140.09
          },
          "averageOverdue": {
            "type": "number",
            "format": "float",
            "example": 40604.84
          },
          "highestCreditExposureCombinedSuppliers": {
            "type": "number",
            "format": "float"
          },
          "highestCreditExposureSingleSupplier": {
            "type": "number",
            "format": "float"
          },
          "highestOverdueCreditExposure": {
            "type": "number",
            "format": "float"
          },
          "numberOfTradeLines": {
            "type": "integer",
            "example": 24
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "TableOfStat"
        }
      },
      "TradeHistory": {
        "type": "object",
        "properties": {
          "current": {
            "type": "number",
            "format": "float"
          },
          "extractedDate": {
            "type": "string",
            "format": "date-time"
          },
          "month": {
            "type": "integer"
          },
          "overdue1To30": {
            "type": "number",
            "format": "float"
          },
          "overdue30To60": {
            "type": "number",
            "format": "float"
          },
          "overdue60To90": {
            "type": "number",
            "format": "float"
          },
          "overdueOver90": {
            "type": "number",
            "format": "float"
          },
          "theTotal": {
            "type": "number",
            "format": "float"
          },
          "tradeLines": {
            "type": "integer"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "TradeHistory"
        }
      },
      "UBOResponse": {
        "type": "object",
        "required": ["supplied_data"],
        "properties": {
          "asic_search_timestamp": {
            "description": "If an ASIC search was conducted, what was the date/time in RFC-3339 format\n",
            "type": "string",
            "format": "date-time",
            "example": "2016-08-29T09:12:33.001Z"
          },
          "business_details": {
            "$ref": "#/components/schemas/BusinessDetails"
          },
          "business_screening_result": {
            "$ref": "#/components/schemas/ScreeningResult"
          },
          "error_message": {
            "description": "Only populated if there was an error whilst trying to initiate the UBO check.\n\nSignifies that no other result data will be supplied\n",
            "type": "string"
          },
          "issues_list": {
            "description": "A list of issues encountered whilst processing the UBO request and subsequent KYC/AML checks.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IssueListItems"
            }
          },
          "non_individual_beneficial_owners": {
            "description": "A list of organisations who have been determined to own a (potentially) beneficial interest the company.\n\nThe presence of non_individual_beneficial_owners indicates that not all individual ultimate beneficial owners could be determined. \nExamples may include public companies, listed companies, foreign companies, corporate trusts or other entities whose beneficial owners are not readily available.\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NonIndividualBeneficialOwner"
            }
          },
          "officeholders": {
            "description": "A list of individuals who serve as current office holders the company\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IndividualData"
            }
          },
          "supplied_data": {
            "$ref": "#/components/schemas/SuppliedData"
          },
          "supplied_data_matches": {
            "$ref": "#/components/schemas/SuppliedDataMatches"
          },
          "ultimate_beneficial_owners": {
            "description": "A list of individuals who have been determined to own, either directly or indirectly, 25% or more of the company\n",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IndividualData"
            }
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "UBOResponse"
        }
      },
      "USOfficerDTO": {
        "type": "object",
        "properties": {
          "Address": {
            "type": "string"
          },
          "BusinessAddress": {
            "$ref": "#/components/schemas/ArrayOfString1"
          },
          "Date": {
            "type": "string"
          },
          "MailingAddress": {
            "type": "string"
          },
          "Name": {
            "type": "string"
          },
          "Title": {
            "type": "string"
          },
          "Type": {
            "type": "string"
          }
        },
        "x-go-type": {
          "import": {
            "alias": "models_common",
            "package": "bitbucket.org/ff_common/models/common"
          },
          "type": "USOfficerDTO"
        }
      }
    }
  },
  "x-readme": {
    "explorer-enabled": true,
    "proxy-enabled": true
  }
}
